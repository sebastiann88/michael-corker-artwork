"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-photo-album";
exports.ids = ["vendor-chunks/react-photo-album"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-photo-album/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-photo-album/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhotoAlbum: () => (/* binding */ PhotoAlbum),\n/* harmony export */   \"default\": () => (/* binding */ PhotoAlbum),\n/* harmony export */   unstable_computeColumnsLayout: () => (/* binding */ computeColumnsLayout),\n/* harmony export */   unstable_computeMasonryLayout: () => (/* binding */ computeMasonryLayout),\n/* harmony export */   unstable_computeRowsLayout: () => (/* binding */ computeRowsLayout)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ PhotoAlbum,default,unstable_computeColumnsLayout,unstable_computeMasonryLayout,unstable_computeRowsLayout auto */ \nfunction ratio({ width, height }) {\n    return width / height;\n}\nfunction round(value, decimals = 0) {\n    const factor = 10 ** decimals;\n    return Math.round((value + Number.EPSILON) * factor) / factor;\n}\nfunction rankingFunctionComparator(rank) {\n    return (a, b)=>rank(b) - rank(a);\n}\nclass MinHeap {\n    constructor(comparator){\n        this.comparator = comparator;\n        this.heap = [];\n        this.n = 0;\n    }\n    greater(i, j) {\n        return this.comparator(this.heap[i], this.heap[j]) < 0;\n    }\n    swap(i, j) {\n        const temp = this.heap[i];\n        this.heap[i] = this.heap[j];\n        this.heap[j] = temp;\n    }\n    swim(i) {\n        let k = i;\n        let k2 = Math.floor(k / 2);\n        while(k > 1 && this.greater(k2, k)){\n            this.swap(k2, k);\n            k = k2;\n            k2 = Math.floor(k / 2);\n        }\n    }\n    sink(i) {\n        let k = i;\n        let k2 = k * 2;\n        while(k2 <= this.n){\n            if (k2 < this.n && this.greater(k2, k2 + 1)) k2 += 1;\n            if (!this.greater(k, k2)) break;\n            this.swap(k, k2);\n            k = k2;\n            k2 = k * 2;\n        }\n    }\n    push(element) {\n        this.n += 1;\n        this.heap[this.n] = element;\n        this.swim(this.n);\n    }\n    pop() {\n        if (this.n === 0) return void 0;\n        this.swap(1, this.n);\n        this.n -= 1;\n        const max = this.heap.pop();\n        this.sink(1);\n        return max;\n    }\n    size() {\n        return this.n;\n    }\n}\nfunction buildPrecedentsMap(graph, startNode, endNode) {\n    const precedentsMap = /* @__PURE__ */ new Map();\n    const visited = /* @__PURE__ */ new Set();\n    const storedShortestPaths = /* @__PURE__ */ new Map();\n    storedShortestPaths.set(startNode, 0);\n    const queue = new MinHeap(rankingFunctionComparator((el)=>el.weight));\n    queue.push({\n        id: startNode,\n        weight: 0\n    });\n    while(queue.size() > 0){\n        const { id, weight } = queue.pop();\n        if (!visited.has(id)) {\n            const neighboringNodes = graph(id);\n            visited.add(id);\n            neighboringNodes.forEach((neighborWeight, neighbor)=>{\n                const newWeight = weight + neighborWeight;\n                const currentId = precedentsMap.get(neighbor);\n                const currentWeight = storedShortestPaths.get(neighbor);\n                if (currentWeight === void 0 || currentWeight > newWeight && (currentWeight / newWeight > 1.005 || currentId !== void 0 && currentId < id)) {\n                    storedShortestPaths.set(neighbor, newWeight);\n                    queue.push({\n                        id: neighbor,\n                        weight: newWeight\n                    });\n                    precedentsMap.set(neighbor, id);\n                }\n            });\n        }\n    }\n    return storedShortestPaths.has(endNode) ? precedentsMap : void 0;\n}\nfunction getPathFromPrecedentsMap(precedentsMap, endNode) {\n    const nodes = [];\n    for(let node = endNode; node !== void 0; node = precedentsMap.get(node)){\n        nodes.push(node);\n    }\n    return nodes.reverse();\n}\nfunction findShortestPath(graph, startNode, endNode) {\n    const precedentsMap = buildPrecedentsMap(graph, startNode, endNode);\n    return precedentsMap ? getPathFromPrecedentsMap(precedentsMap, endNode) : void 0;\n}\nfunction findIdealNodeSearch({ photos, targetRowHeight, containerWidth }) {\n    const minRatio = photos.reduce((acc, photo)=>Math.min(ratio(photo), acc), Number.MAX_VALUE);\n    return round(containerWidth / targetRowHeight / minRatio) + 2;\n}\nfunction getCommonHeight(row, containerWidth, spacing, padding) {\n    const rowWidth = containerWidth - (row.length - 1) * spacing - 2 * padding * row.length;\n    const totalAspectRatio = row.reduce((acc, photo)=>acc + ratio(photo), 0);\n    return rowWidth / totalAspectRatio;\n}\nfunction cost(photos, i, j, width, targetRowHeight, spacing, padding) {\n    const row = photos.slice(i, j);\n    const commonHeight = getCommonHeight(row, width, spacing, padding);\n    return commonHeight > 0 ? (commonHeight - targetRowHeight) ** 2 * row.length : void 0;\n}\nfunction makeGetRowNeighbors({ photos, layoutOptions, targetRowHeight, limitNodeSearch, rowConstraints }) {\n    return (node)=>{\n        var _a, _b;\n        const { containerWidth, spacing, padding } = layoutOptions;\n        const results = /* @__PURE__ */ new Map();\n        results.set(node, 0);\n        const startOffset = (_a = rowConstraints == null ? void 0 : rowConstraints.minPhotos) != null ? _a : 1;\n        const endOffset = Math.min(limitNodeSearch, (_b = rowConstraints == null ? void 0 : rowConstraints.maxPhotos) != null ? _b : Infinity);\n        for(let i = node + startOffset; i < photos.length + 1; i += 1){\n            if (i - node > endOffset) break;\n            const currentCost = cost(photos, node, i, containerWidth, targetRowHeight, spacing, padding);\n            if (currentCost === void 0) break;\n            results.set(i, currentCost);\n        }\n        return results;\n    };\n}\nfunction computeRowsLayout({ photos, layoutOptions }) {\n    const { spacing, padding, containerWidth, targetRowHeight, rowConstraints } = layoutOptions;\n    const limitNodeSearch = findIdealNodeSearch({\n        photos,\n        containerWidth,\n        targetRowHeight\n    });\n    const getNeighbors = makeGetRowNeighbors({\n        photos,\n        layoutOptions,\n        targetRowHeight,\n        limitNodeSearch,\n        rowConstraints\n    });\n    const path = findShortestPath(getNeighbors, 0, photos.length);\n    if (path === void 0) return void 0;\n    const layout = [];\n    for(let i = 1; i < path.length; i += 1){\n        const row = photos.map((photo, index)=>({\n                photo,\n                index\n            })).slice(path[i - 1], path[i]);\n        const height = getCommonHeight(row.map(({ photo })=>photo), containerWidth, spacing, padding);\n        layout.push(row.map(({ photo, index }, photoIndex)=>({\n                photo,\n                layout: {\n                    height,\n                    width: height * ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: row.length\n                }\n            })));\n    }\n    return layout;\n}\nfunction clsx(...classes) {\n    return [\n        ...classes\n    ].filter((cls)=>Boolean(cls)).join(\" \");\n}\nfunction calcWidth(base, photoLayout, layoutOptions) {\n    const { width, photosCount } = photoLayout;\n    const { layout, spacing, padding, containerWidth } = layoutOptions;\n    const count = layout === \"rows\" ? photosCount : layoutOptions.columns;\n    const gaps = spacing * (count - 1) + 2 * padding * count;\n    return `calc((${base} - ${gaps}px) / ${round((containerWidth - gaps) / width, 5)})`;\n}\nfunction cssPhotoWidth(layout, layoutOptions) {\n    return layoutOptions.layout !== \"rows\" ? `calc(100% - ${2 * layoutOptions.padding}px)` : calcWidth(\"100%\", layout, layoutOptions);\n}\nfunction calculateSizesValue(size, layout, layoutOptions) {\n    var _a, _b;\n    return calcWidth((_b = (_a = size.match(/^\\s*calc\\((.*)\\)\\s*$/)) == null ? void 0 : _a[1]) != null ? _b : size, layout, layoutOptions);\n}\nfunction srcSetAndSizes(photo, layout, layoutOptions) {\n    var _a;\n    let srcSet;\n    let sizes;\n    const images = photo.srcSet || photo.images;\n    if (images && images.length > 0) {\n        srcSet = images.concat(!images.find(({ width })=>width === photo.width) ? [\n            {\n                src: photo.src,\n                width: photo.width,\n                height: photo.height\n            }\n        ] : []).sort((first, second)=>first.width - second.width).map((image)=>`${image.src} ${image.width}w`).join(\", \");\n    }\n    if ((_a = layoutOptions.sizes) == null ? void 0 : _a.size) {\n        sizes = (layoutOptions.sizes.sizes || []).map(({ viewport, size })=>`${viewport} ${calculateSizesValue(size, layout, layoutOptions)}`).concat(calculateSizesValue(layoutOptions.sizes.size, layout, layoutOptions)).join(\", \");\n    } else {\n        sizes = `${Math.ceil(layout.width / layoutOptions.containerWidth * 100)}vw`;\n    }\n    return {\n        srcSet,\n        sizes\n    };\n}\nfunction PhotoRenderer(props) {\n    var _a, _b;\n    const { photo, layout, layoutOptions, imageProps: { style, className, ...restImageProps } = {}, renderPhoto } = props;\n    const { onClick } = layoutOptions;\n    const imageStyle = {\n        display: \"block\",\n        boxSizing: \"content-box\",\n        width: cssPhotoWidth(layout, layoutOptions),\n        height: \"auto\",\n        aspectRatio: `${photo.width} / ${photo.height}`,\n        ...layoutOptions.padding ? {\n            padding: `${layoutOptions.padding}px`\n        } : null,\n        ...(layoutOptions.layout === \"columns\" || layoutOptions.layout === \"masonry\") && layout.photoIndex < layout.photosCount - 1 ? {\n            marginBottom: `${layoutOptions.spacing}px`\n        } : null,\n        ...onClick ? {\n            cursor: \"pointer\"\n        } : null,\n        ...style\n    };\n    const handleClick = onClick ? (event)=>{\n        onClick({\n            event,\n            photo,\n            index: layout.index\n        });\n    } : void 0;\n    const imageProps = {\n        src: photo.src,\n        alt: (_a = photo.alt) != null ? _a : \"\",\n        title: photo.title,\n        onClick: handleClick,\n        style: imageStyle,\n        className: clsx(\"react-photo-album--photo\", className),\n        loading: \"lazy\",\n        decoding: \"async\",\n        ...srcSetAndSizes(photo, layout, layoutOptions),\n        ...restImageProps\n    };\n    const renderDefaultPhoto = (options)=>{\n        const { src, alt, srcSet, sizes, style: unwrappedStyle, ...rest } = imageProps;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n            alt,\n            ...srcSet ? {\n                srcSet,\n                sizes\n            } : null,\n            src,\n            style: (options == null ? void 0 : options.wrapped) ? {\n                display: \"block\",\n                width: \"100%\",\n                height: \"100%\"\n            } : unwrappedStyle,\n            ...rest\n        });\n    };\n    const wrapperStyle = (({ display, boxSizing, width, aspectRatio, padding, marginBottom, cursor })=>({\n            display,\n            boxSizing,\n            width,\n            aspectRatio,\n            padding,\n            marginBottom,\n            cursor\n        }))(imageStyle);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (_b = renderPhoto == null ? void 0 : renderPhoto({\n        photo,\n        layout,\n        layoutOptions,\n        imageProps,\n        renderDefaultPhoto,\n        wrapperStyle\n    })) != null ? _b : renderDefaultPhoto());\n}\nfunction defaultRenderRowContainer({ rowContainerProps, children }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...rowContainerProps\n    }, children);\n}\nfunction RowContainerRenderer(props) {\n    const { layoutOptions, rowIndex, rowsCount, renderRowContainer, rowContainerProps: { style, className, ...restRowContainerProps } = {}, children } = props;\n    const rowContainerProps = {\n        className: clsx(\"react-photo-album--row\", className),\n        style: {\n            display: \"flex\",\n            flexDirection: \"row\",\n            flexWrap: \"nowrap\",\n            alignItems: \"flex-start\",\n            justifyContent: \"space-between\",\n            ...rowIndex < rowsCount - 1 ? {\n                marginBottom: `${layoutOptions.spacing}px`\n            } : null,\n            ...style\n        },\n        ...restRowContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderRowContainer != null ? renderRowContainer : defaultRenderRowContainer)({\n        layoutOptions,\n        rowIndex,\n        rowsCount,\n        rowContainerProps,\n        children\n    }));\n}\nfunction RowsLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderRowContainer, componentsProps: { imageProps, rowContainerProps } } = props;\n    const rowsLayout = computeRowsLayout({\n        photos,\n        layoutOptions\n    });\n    if (!rowsLayout) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, rowsLayout.map((row, rowIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowContainerRenderer, {\n            key: `row-${rowIndex}`,\n            layoutOptions,\n            rowIndex,\n            rowsCount: rowsLayout.length,\n            renderRowContainer,\n            rowContainerProps\n        }, row.map(({ photo, layout })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            })))));\n}\nfunction computeShortestPath(graph, pathLength, startNode, endNode) {\n    const matrix = /* @__PURE__ */ new Map();\n    const queue = /* @__PURE__ */ new Set();\n    queue.add(startNode);\n    for(let length = 0; length < pathLength; length += 1){\n        const currentQueue = [\n            ...queue.keys()\n        ];\n        queue.clear();\n        currentQueue.forEach((node)=>{\n            const accumulatedWeight = length > 0 ? matrix.get(node)[length].weight : 0;\n            graph(node).forEach(({ neighbor, weight })=>{\n                let paths = matrix.get(neighbor);\n                if (!paths) {\n                    paths = [];\n                    matrix.set(neighbor, paths);\n                }\n                const newWeight = accumulatedWeight + weight;\n                const nextPath = paths[length + 1];\n                if (!nextPath || nextPath.weight > newWeight && (nextPath.weight / newWeight > 1.0001 || node < nextPath.node)) {\n                    paths[length + 1] = {\n                        node,\n                        weight: newWeight\n                    };\n                }\n                if (length < pathLength - 1 && neighbor !== endNode) {\n                    queue.add(neighbor);\n                }\n            });\n        });\n    }\n    return matrix;\n}\nfunction reconstructShortestPath(matrix, pathLength, endNode) {\n    const path = [\n        endNode\n    ];\n    for(let node = endNode, length = pathLength; length > 0; length -= 1){\n        node = matrix.get(node)[length].node;\n        path.push(node);\n    }\n    return path.reverse();\n}\nfunction findShortestPathLengthN(graph, pathLength, startNode, endNode) {\n    return reconstructShortestPath(computeShortestPath(graph, pathLength, startNode, endNode), pathLength, endNode);\n}\nfunction makeGetColumnNeighbors({ photos, spacing, padding, targetColumnWidth, targetColumnHeight }) {\n    return (node)=>{\n        const results = [];\n        const cutOffHeight = targetColumnHeight * 1.5;\n        let height = targetColumnWidth / ratio(photos[node]) + 2 * padding;\n        for(let i = node + 1; i < photos.length + 1; i += 1){\n            results.push({\n                neighbor: i,\n                weight: (targetColumnHeight - height) ** 2\n            });\n            if (height > cutOffHeight || i === photos.length) {\n                break;\n            }\n            height += targetColumnWidth / ratio(photos[i]) + spacing + 2 * padding;\n        }\n        return results;\n    };\n}\nfunction buildColumnsModel({ path, photos, containerWidth, columnsGaps, columnsRatios, spacing, padding }) {\n    const columnsModel = [];\n    const totalRatio = columnsRatios.reduce((total, columnRatio)=>total + columnRatio, 0);\n    for(let i = 0; i < path.length - 1; i += 1){\n        const column = photos.map((photo, index)=>({\n                photo,\n                index\n            })).slice(path[i], path[i + 1]);\n        const totalAdjustedGaps = columnsRatios.reduce((total, columnRatio, index)=>total + (columnsGaps[i] - columnsGaps[index]) * columnRatio, 0);\n        const columnWidth = (containerWidth - (path.length - 2) * spacing - 2 * (path.length - 1) * padding - totalAdjustedGaps) * columnsRatios[i] / totalRatio;\n        columnsModel.push(column.map(({ photo, index }, photoIndex)=>({\n                photo,\n                layout: {\n                    width: columnWidth,\n                    height: columnWidth / ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: column.length\n                }\n            })));\n    }\n    return columnsModel;\n}\nfunction computeColumnsModel({ photos, layoutOptions, targetColumnWidth }) {\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const columnsGaps = [];\n    const columnsRatios = [];\n    if (photos.length <= columns) {\n        const averageRatio = photos.length > 0 ? photos.reduce((acc, photo)=>acc + ratio(photo), 0) / photos.length : 1;\n        for(let i = 0; i < columns; i += 1){\n            columnsGaps[i] = 2 * padding;\n            columnsRatios[i] = i < photos.length ? ratio(photos[i]) : averageRatio;\n        }\n        const columnsModel2 = buildColumnsModel({\n            path: Array.from({\n                length: columns + 1\n            }).map((_, index)=>Math.min(index, photos.length)),\n            photos,\n            columnsRatios,\n            columnsGaps,\n            containerWidth,\n            spacing,\n            padding\n        });\n        return {\n            columnsGaps,\n            columnsRatios,\n            columnsModel: columnsModel2\n        };\n    }\n    const targetColumnHeight = (photos.reduce((acc, photo)=>acc + targetColumnWidth / ratio(photo), 0) + spacing * (photos.length - columns) + 2 * padding * photos.length) / columns;\n    const getNeighbors = makeGetColumnNeighbors({\n        photos,\n        targetColumnWidth,\n        targetColumnHeight,\n        spacing,\n        padding\n    });\n    const path = findShortestPathLengthN(getNeighbors, columns, 0, photos.length);\n    for(let i = 0; i < path.length - 1; i += 1){\n        const column = photos.slice(path[i], path[i + 1]);\n        columnsGaps[i] = spacing * (column.length - 1) + 2 * padding * column.length;\n        columnsRatios[i] = 1 / column.reduce((acc, photo)=>acc + 1 / ratio(photo), 0);\n    }\n    const columnsModel = buildColumnsModel({\n        path,\n        photos,\n        columnsRatios,\n        columnsGaps,\n        containerWidth,\n        spacing,\n        padding\n    });\n    return {\n        columnsGaps,\n        columnsRatios,\n        columnsModel\n    };\n}\nfunction computeLayout(props) {\n    const { photos, layoutOptions } = props;\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const targetColumnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n    const { columnsGaps, columnsRatios, columnsModel } = computeColumnsModel({\n        photos,\n        layoutOptions,\n        targetColumnWidth\n    });\n    if (columnsModel.findIndex((columnModel)=>columnModel.findIndex(({ layout: { width, height } })=>width < 0 || height < 0) >= 0) >= 0) {\n        if (columns > 1) {\n            return computeLayout({\n                photos,\n                layoutOptions: {\n                    ...layoutOptions,\n                    columns: columns - 1\n                }\n            });\n        }\n        return void 0;\n    }\n    return {\n        columnsModel,\n        columnsGaps,\n        columnsRatios\n    };\n}\nfunction computeColumnsLayout({ photos, layoutOptions }) {\n    return computeLayout({\n        photos,\n        layoutOptions\n    });\n}\nfunction defaultRenderColumnContainer({ columnContainerProps, children }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...columnContainerProps\n    }, children);\n}\nfunction cssColumnWidth(props) {\n    const { layoutOptions, columnIndex, columnsCount, columnsGaps, columnsRatios } = props;\n    const { layout, spacing, padding } = layoutOptions;\n    if (layout === \"masonry\" || !columnsGaps || !columnsRatios) {\n        return `calc((100% - ${spacing * (columnsCount - 1)}px) / ${columnsCount})`;\n    }\n    const totalRatio = columnsRatios.reduce((acc, ratio2)=>acc + ratio2, 0);\n    const totalAdjustedGaps = columnsRatios.reduce((acc, ratio2, index)=>acc + (columnsGaps[columnIndex] - columnsGaps[index]) * ratio2, 0);\n    return `calc((100% - ${round((columnsCount - 1) * spacing + 2 * columnsCount * padding + totalAdjustedGaps, 3)}px) * ${round(columnsRatios[columnIndex] / totalRatio, 5)} + ${2 * padding}px)`;\n}\nfunction ColumnContainerRenderer(props) {\n    const { layoutOptions, renderColumnContainer, children, columnContainerProps: { style, className, ...restColumnContainerProps } = {}, ...rest } = props;\n    const columnContainerProps = {\n        className: clsx(\"react-photo-album--column\", className),\n        style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            flexWrap: \"nowrap\",\n            alignItems: \"flex-start\",\n            width: cssColumnWidth(props),\n            justifyContent: layoutOptions.layout === \"columns\" ? \"space-between\" : \"flex-start\",\n            ...style\n        },\n        ...restColumnContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderColumnContainer != null ? renderColumnContainer : defaultRenderColumnContainer)({\n        layoutOptions,\n        columnContainerProps,\n        children,\n        ...rest\n    }));\n}\nfunction ColumnsLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderColumnContainer, componentsProps: { imageProps, columnContainerProps } } = props;\n    const columnsLayout = computeColumnsLayout({\n        photos,\n        layoutOptions\n    });\n    if (!columnsLayout) return null;\n    const { columnsModel, columnsRatios, columnsGaps } = columnsLayout;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, columnsModel.map((column, columnIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnContainerRenderer, {\n            key: `column-${columnIndex}`,\n            layoutOptions,\n            columnIndex,\n            columnsCount: columnsModel.length,\n            columnsGaps,\n            columnsRatios,\n            renderColumnContainer,\n            columnContainerProps\n        }, column.map(({ photo, layout })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            })))));\n}\nfunction computeMasonryLayout(props) {\n    const { photos, layoutOptions } = props;\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const columnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n    if (columnWidth <= 0) {\n        return columns > 1 ? computeMasonryLayout({\n            ...props,\n            layoutOptions: {\n                ...layoutOptions,\n                columns: columns - 1\n            }\n        }) : void 0;\n    }\n    const columnsCurrentTopPositions = [];\n    for(let i = 0; i < columns; i += 1){\n        columnsCurrentTopPositions[i] = 0;\n    }\n    const columnsModel = photos.reduce((model, photo, index)=>{\n        const shortestColumn = columnsCurrentTopPositions.reduce((currentShortestColumn, item, i)=>item < columnsCurrentTopPositions[currentShortestColumn] - 1 ? i : currentShortestColumn, 0);\n        columnsCurrentTopPositions[shortestColumn] = columnsCurrentTopPositions[shortestColumn] + columnWidth / ratio(photo) + spacing + 2 * padding;\n        model[shortestColumn].push({\n            photo,\n            index\n        });\n        return model;\n    }, Array.from({\n        length: columns\n    }).map(()=>[]));\n    return columnsModel.map((column)=>column.map(({ photo, index }, photoIndex)=>({\n                photo,\n                layout: {\n                    width: columnWidth,\n                    height: columnWidth / ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: column.length\n                }\n            })));\n}\nfunction MasonryLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderColumnContainer, componentsProps: { imageProps, columnContainerProps } } = props;\n    const masonryLayout = computeMasonryLayout({\n        photos,\n        layoutOptions\n    });\n    if (!masonryLayout) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, masonryLayout.map((column, columnIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnContainerRenderer, {\n            key: `masonry-column-${columnIndex}`,\n            layoutOptions,\n            columnsCount: masonryLayout.length,\n            columnIndex,\n            renderColumnContainer,\n            columnContainerProps\n        }, column.map(({ photo, layout })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            })))));\n}\nfunction defaultRenderContainer({ containerProps, children, containerRef }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: containerRef,\n        ...containerProps\n    }, children);\n}\nfunction ContainerRenderer(props) {\n    const { layout, renderContainer, children, containerRef, containerProps: { style, className, ...restContainerProps } = {} } = props;\n    const containerProps = {\n        className: clsx(\"react-photo-album\", `react-photo-album--${layout}`, className),\n        style: {\n            display: \"flex\",\n            flexWrap: \"nowrap\",\n            justifyContent: \"space-between\",\n            flexDirection: layout === \"rows\" ? \"column\" : \"row\",\n            ...style\n        },\n        ...restContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderContainer != null ? renderContainer : defaultRenderContainer)({\n        containerProps,\n        containerRef,\n        layout,\n        children\n    }));\n}\nfunction useArray(array) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(array);\n    if (!array || !ref.current || array.join() !== ref.current.join()) {\n        ref.current = array;\n    }\n    return ref.current;\n}\nfunction containerWidthReducer(state, { newContainerWidth, newScrollbarWidth }) {\n    const { containerWidth, scrollbarWidth } = state;\n    if (containerWidth !== void 0 && scrollbarWidth !== void 0 && newContainerWidth !== void 0 && newScrollbarWidth !== void 0 && newContainerWidth > containerWidth && newContainerWidth - containerWidth <= 20 && newScrollbarWidth < scrollbarWidth) {\n        return {\n            containerWidth,\n            scrollbarWidth: newScrollbarWidth\n        };\n    }\n    return containerWidth !== newContainerWidth || scrollbarWidth !== newScrollbarWidth ? {\n        containerWidth: newContainerWidth,\n        scrollbarWidth: newScrollbarWidth\n    } : state;\n}\nfunction resolveContainerWidth(el, breakpoints2) {\n    let width = el == null ? void 0 : el.clientWidth;\n    if (width !== void 0 && breakpoints2 && breakpoints2.length > 0) {\n        const sorted = [\n            ...breakpoints2.filter((x)=>x > 0)\n        ].sort((a, b)=>b - a);\n        sorted.push(Math.floor(sorted[sorted.length - 1] / 2));\n        const threshold = width;\n        width = sorted.find((breakpoint, index)=>breakpoint <= threshold || index === sorted.length - 1);\n    }\n    return width;\n}\nfunction useContainerWidth(breakpoints2, defaultContainerWidth) {\n    const [{ containerWidth }, dispatch] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(containerWidthReducer, {\n        containerWidth: defaultContainerWidth\n    });\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const observerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const containerRef = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        var _a;\n        (_a = observerRef.current) == null ? void 0 : _a.disconnect();\n        observerRef.current = void 0;\n        ref.current = node;\n        const updateWidth = ()=>dispatch({\n                newContainerWidth: resolveContainerWidth(ref.current, breakpoints2),\n                newScrollbarWidth: window.innerWidth - document.documentElement.clientWidth\n            });\n        updateWidth();\n        if (node && typeof ResizeObserver !== \"undefined\") {\n            observerRef.current = new ResizeObserver(updateWidth);\n            observerRef.current.observe(node);\n        }\n    }, [\n        breakpoints2\n    ]);\n    return {\n        containerRef,\n        containerWidth\n    };\n}\nconst breakpoints = Object.freeze([\n    1200,\n    600,\n    300,\n    0\n]);\nfunction unwrap(value, arg) {\n    return typeof value === \"function\" ? value(arg) : value;\n}\nfunction unwrapParameter(value, containerWidth) {\n    return typeof value !== \"undefined\" ? unwrap(value, containerWidth) : void 0;\n}\nfunction selectResponsiveValue(values, containerWidth) {\n    const index = breakpoints.findIndex((breakpoint)=>breakpoint <= containerWidth);\n    return unwrap(values[index >= 0 ? index : 0], containerWidth);\n}\nfunction resolveResponsiveParameter(parameter, containerWidth, values, minValue = 0) {\n    const value = unwrapParameter(parameter, containerWidth);\n    return Math.round(Math.max(value === void 0 ? selectResponsiveValue(values, containerWidth) : value, minValue));\n}\nfunction resolveLayoutOptions({ layout, onClick, containerWidth, targetRowHeight, rowConstraints, columns, spacing, padding, sizes }) {\n    return {\n        layout,\n        onClick,\n        containerWidth,\n        columns: resolveResponsiveParameter(columns, containerWidth, [\n            5,\n            4,\n            3,\n            2\n        ], 1),\n        spacing: resolveResponsiveParameter(spacing, containerWidth, [\n            20,\n            15,\n            10,\n            5\n        ]),\n        padding: resolveResponsiveParameter(padding, containerWidth, [\n            0,\n            0,\n            0,\n            0,\n            0\n        ]),\n        targetRowHeight: resolveResponsiveParameter(targetRowHeight, containerWidth, [\n            (w)=>w / 5,\n            (w)=>w / 4,\n            (w)=>w / 3,\n            (w)=>w / 2\n        ]),\n        rowConstraints: unwrapParameter(rowConstraints, containerWidth),\n        sizes\n    };\n}\nfunction resolveComponentsProps(props, containerWidth, layoutOptions) {\n    const { photos, componentsProps: componentsPropsProp } = props;\n    const componentsProps = unwrap(componentsPropsProp, containerWidth) || {};\n    if (layoutOptions) {\n        const { layout, spacing, padding, rowConstraints } = layoutOptions;\n        if (layout === \"rows\") {\n            const { singleRowMaxHeight } = rowConstraints || {};\n            if (singleRowMaxHeight) {\n                const maxWidth = Math.floor(photos.reduce((acc, { width, height })=>acc + width / height * singleRowMaxHeight - 2 * padding, padding * photos.length * 2 + spacing * (photos.length - 1)));\n                if (maxWidth > 0) {\n                    componentsProps.containerProps = componentsProps.containerProps || {};\n                    componentsProps.containerProps.style = {\n                        maxWidth,\n                        ...componentsProps.containerProps.style\n                    };\n                }\n            }\n        }\n    }\n    return componentsProps;\n}\nfunction renderLayout(props, componentsProps, layoutOptions) {\n    const { photos, layout, renderPhoto, renderRowContainer, renderColumnContainer } = props;\n    const commonLayoutProps = {\n        photos,\n        renderPhoto,\n        componentsProps\n    };\n    if (layout === \"rows\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowsLayout, {\n            layoutOptions,\n            renderRowContainer,\n            ...commonLayoutProps\n        });\n    }\n    if (layout === \"columns\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnsLayout, {\n            layoutOptions,\n            renderColumnContainer,\n            ...commonLayoutProps\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MasonryLayout, {\n        layoutOptions,\n        renderColumnContainer,\n        ...commonLayoutProps\n    });\n}\nfunction PhotoAlbum(props) {\n    const { photos, layout, renderContainer, defaultContainerWidth, breakpoints: breakpoints2 } = props;\n    const { containerRef, containerWidth } = useContainerWidth(useArray(breakpoints2), defaultContainerWidth);\n    if (!layout || ![\n        \"rows\",\n        \"columns\",\n        \"masonry\"\n    ].includes(layout) || !Array.isArray(photos)) return null;\n    const layoutOptions = containerWidth ? resolveLayoutOptions({\n        containerWidth,\n        ...props\n    }) : void 0;\n    const componentsProps = resolveComponentsProps(props, containerWidth, layoutOptions);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContainerRenderer, {\n        layout,\n        containerRef,\n        renderContainer,\n        containerProps: componentsProps.containerProps\n    }, layoutOptions && renderLayout(props, componentsProps, layoutOptions));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGhvdG8tYWxidW0vZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OytKQUMrQjtBQUMvQixTQUFTQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQzlCLE9BQU9ELFFBQVFDO0FBQ2pCO0FBQ0EsU0FBU0MsTUFBTUMsS0FBSyxFQUFFQyxXQUFXLENBQUM7SUFDaEMsTUFBTUMsU0FBUyxNQUFNRDtJQUNyQixPQUFPRSxLQUFLSixLQUFLLENBQUMsQ0FBQ0MsUUFBUUksT0FBT0MsT0FBTyxJQUFJSCxVQUFVQTtBQUN6RDtBQUNBLFNBQVNJLDBCQUEwQkMsSUFBSTtJQUNyQyxPQUFPLENBQUNDLEdBQUdDLElBQU1GLEtBQUtFLEtBQUtGLEtBQUtDO0FBQ2xDO0FBQ0EsTUFBTUU7SUFDSkMsWUFBWUMsVUFBVSxDQUFFO1FBQ3RCLElBQUksQ0FBQ0EsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLElBQUksR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDQyxDQUFDLEdBQUc7SUFDWDtJQUNBQyxRQUFRQyxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDTCxVQUFVLENBQUMsSUFBSSxDQUFDQyxJQUFJLENBQUNHLEVBQUUsRUFBRSxJQUFJLENBQUNILElBQUksQ0FBQ0ksRUFBRSxJQUFJO0lBQ3ZEO0lBQ0FDLEtBQUtGLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ1QsTUFBTUUsT0FBTyxJQUFJLENBQUNOLElBQUksQ0FBQ0csRUFBRTtRQUN6QixJQUFJLENBQUNILElBQUksQ0FBQ0csRUFBRSxHQUFHLElBQUksQ0FBQ0gsSUFBSSxDQUFDSSxFQUFFO1FBQzNCLElBQUksQ0FBQ0osSUFBSSxDQUFDSSxFQUFFLEdBQUdFO0lBQ2pCO0lBQ0FDLEtBQUtKLENBQUMsRUFBRTtRQUNOLElBQUlLLElBQUlMO1FBQ1IsSUFBSU0sS0FBS25CLEtBQUtvQixLQUFLLENBQUNGLElB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LGlCQUFpQjtRQUN0QjtJQUVKO0lBQ0EsSUFBSTFMLFdBQVcsV0FBVztRQUN4QixxQkFBT3BHLGdEQUFtQixDQUN4QjZOLGVBQ0E7WUFDRXhJO1lBQ0FzSTtZQUNBLEdBQUdtRSxpQkFBaUI7UUFDdEI7SUFFSjtJQUNBLHFCQUFPOVIsZ0RBQW1CLENBQ3hCcU8sZUFDQTtRQUNFaEo7UUFDQXNJO1FBQ0EsR0FBR21FLGlCQUFpQjtJQUN0QjtBQUVKO0FBQ0EsU0FBU0MsV0FBV3pKLEtBQUs7SUFDdkIsTUFBTSxFQUFFckUsTUFBTSxFQUFFbUMsTUFBTSxFQUFFd0ksZUFBZSxFQUFFbUIscUJBQXFCLEVBQUVhLGFBQWFwQixZQUFZLEVBQUUsR0FBR2xIO0lBQzlGLE1BQU0sRUFBRW1HLFlBQVksRUFBRXRLLGNBQWMsRUFBRSxHQUFHMkwsa0JBQWtCaEIsU0FBU1UsZUFBZU87SUFDbkYsSUFBSSxDQUFDM0osVUFBVSxDQUFDO1FBQUM7UUFBUTtRQUFXO0tBQVUsQ0FBQzRMLFFBQVEsQ0FBQzVMLFdBQVcsQ0FBQ3lHLE1BQU1vRixPQUFPLENBQUNoTyxTQUFTLE9BQU87SUFDbEcsTUFBTW9CLGdCQUFnQmxCLGlCQUFpQm9OLHFCQUFxQjtRQUFFcE47UUFBZ0IsR0FBR21FLEtBQUs7SUFBQyxLQUFLLEtBQUs7SUFDakcsTUFBTXdDLGtCQUFrQjJHLHVCQUF1Qm5KLE9BQU9uRSxnQkFBZ0JrQjtJQUN0RSxxQkFBT3JGLGdEQUFtQixDQUN4QjJPLG1CQUNBO1FBQ0V2STtRQUNBcUk7UUFDQUc7UUFDQUosZ0JBQWdCMUQsZ0JBQWdCMEQsY0FBYztJQUNoRCxHQUNBbkosaUJBQWlCd00sYUFBYXZKLE9BQU93QyxpQkFBaUJ6RjtBQUUxRDtBQU9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljaGFlbC1jb3JrZXItYXJ0d29yay8uL25vZGVfbW9kdWxlcy9yZWFjdC1waG90by1hbGJ1bS9kaXN0L2luZGV4Lm1qcz9iNDY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiByYXRpbyh7IHdpZHRoLCBoZWlnaHQgfSkge1xuICByZXR1cm4gd2lkdGggLyBoZWlnaHQ7XG59XG5mdW5jdGlvbiByb3VuZCh2YWx1ZSwgZGVjaW1hbHMgPSAwKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRlY2ltYWxzO1xuICByZXR1cm4gTWF0aC5yb3VuZCgodmFsdWUgKyBOdW1iZXIuRVBTSUxPTikgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuZnVuY3Rpb24gcmFua2luZ0Z1bmN0aW9uQ29tcGFyYXRvcihyYW5rKSB7XG4gIHJldHVybiAoYSwgYikgPT4gcmFuayhiKSAtIHJhbmsoYSk7XG59XG5jbGFzcyBNaW5IZWFwIHtcbiAgY29uc3RydWN0b3IoY29tcGFyYXRvcikge1xuICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgdGhpcy5oZWFwID0gW107XG4gICAgdGhpcy5uID0gMDtcbiAgfVxuICBncmVhdGVyKGksIGopIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJhdG9yKHRoaXMuaGVhcFtpXSwgdGhpcy5oZWFwW2pdKSA8IDA7XG4gIH1cbiAgc3dhcChpLCBqKSB7XG4gICAgY29uc3QgdGVtcCA9IHRoaXMuaGVhcFtpXTtcbiAgICB0aGlzLmhlYXBbaV0gPSB0aGlzLmhlYXBbal07XG4gICAgdGhpcy5oZWFwW2pdID0gdGVtcDtcbiAgfVxuICBzd2ltKGkpIHtcbiAgICBsZXQgayA9IGk7XG4gICAgbGV0IGsyID0gTWF0aC5mbG9vcihrIC8gMik7XG4gICAgd2hpbGUgKGsgPiAxICYmIHRoaXMuZ3JlYXRlcihrMiwgaykpIHtcbiAgICAgIHRoaXMuc3dhcChrMiwgayk7XG4gICAgICBrID0gazI7XG4gICAgICBrMiA9IE1hdGguZmxvb3IoayAvIDIpO1xuICAgIH1cbiAgfVxuICBzaW5rKGkpIHtcbiAgICBsZXQgayA9IGk7XG4gICAgbGV0IGsyID0gayAqIDI7XG4gICAgd2hpbGUgKGsyIDw9IHRoaXMubikge1xuICAgICAgaWYgKGsyIDwgdGhpcy5uICYmIHRoaXMuZ3JlYXRlcihrMiwgazIgKyAxKSkgazIgKz0gMTtcbiAgICAgIGlmICghdGhpcy5ncmVhdGVyKGssIGsyKSkgYnJlYWs7XG4gICAgICB0aGlzLnN3YXAoaywgazIpO1xuICAgICAgayA9IGsyO1xuICAgICAgazIgPSBrICogMjtcbiAgICB9XG4gIH1cbiAgcHVzaChlbGVtZW50KSB7XG4gICAgdGhpcy5uICs9IDE7XG4gICAgdGhpcy5oZWFwW3RoaXMubl0gPSBlbGVtZW50O1xuICAgIHRoaXMuc3dpbSh0aGlzLm4pO1xuICB9XG4gIHBvcCgpIHtcbiAgICBpZiAodGhpcy5uID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHRoaXMuc3dhcCgxLCB0aGlzLm4pO1xuICAgIHRoaXMubiAtPSAxO1xuICAgIGNvbnN0IG1heCA9IHRoaXMuaGVhcC5wb3AoKTtcbiAgICB0aGlzLnNpbmsoMSk7XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLm47XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkUHJlY2VkZW50c01hcChncmFwaCwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IHByZWNlZGVudHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB2aXNpdGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc3RvcmVkU2hvcnRlc3RQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0b3JlZFNob3J0ZXN0UGF0aHMuc2V0KHN0YXJ0Tm9kZSwgMCk7XG4gIGNvbnN0IHF1ZXVlID0gbmV3IE1pbkhlYXAocmFua2luZ0Z1bmN0aW9uQ29tcGFyYXRvcigoZWwpID0+IGVsLndlaWdodCkpO1xuICBxdWV1ZS5wdXNoKHsgaWQ6IHN0YXJ0Tm9kZSwgd2VpZ2h0OiAwIH0pO1xuICB3aGlsZSAocXVldWUuc2l6ZSgpID4gMCkge1xuICAgIGNvbnN0IHsgaWQsIHdlaWdodCB9ID0gcXVldWUucG9wKCk7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhpZCkpIHtcbiAgICAgIGNvbnN0IG5laWdoYm9yaW5nTm9kZXMgPSBncmFwaChpZCk7XG4gICAgICB2aXNpdGVkLmFkZChpZCk7XG4gICAgICBuZWlnaGJvcmluZ05vZGVzLmZvckVhY2goKG5laWdoYm9yV2VpZ2h0LCBuZWlnaGJvcikgPT4ge1xuICAgICAgICBjb25zdCBuZXdXZWlnaHQgPSB3ZWlnaHQgKyBuZWlnaGJvcldlaWdodDtcbiAgICAgICAgY29uc3QgY3VycmVudElkID0gcHJlY2VkZW50c01hcC5nZXQobmVpZ2hib3IpO1xuICAgICAgICBjb25zdCBjdXJyZW50V2VpZ2h0ID0gc3RvcmVkU2hvcnRlc3RQYXRocy5nZXQobmVpZ2hib3IpO1xuICAgICAgICBpZiAoY3VycmVudFdlaWdodCA9PT0gdm9pZCAwIHx8IGN1cnJlbnRXZWlnaHQgPiBuZXdXZWlnaHQgJiYgKGN1cnJlbnRXZWlnaHQgLyBuZXdXZWlnaHQgPiAxLjAwNSB8fCBjdXJyZW50SWQgIT09IHZvaWQgMCAmJiBjdXJyZW50SWQgPCBpZCkpIHtcbiAgICAgICAgICBzdG9yZWRTaG9ydGVzdFBhdGhzLnNldChuZWlnaGJvciwgbmV3V2VpZ2h0KTtcbiAgICAgICAgICBxdWV1ZS5wdXNoKHsgaWQ6IG5laWdoYm9yLCB3ZWlnaHQ6IG5ld1dlaWdodCB9KTtcbiAgICAgICAgICBwcmVjZWRlbnRzTWFwLnNldChuZWlnaGJvciwgaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0b3JlZFNob3J0ZXN0UGF0aHMuaGFzKGVuZE5vZGUpID8gcHJlY2VkZW50c01hcCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFBhdGhGcm9tUHJlY2VkZW50c01hcChwcmVjZWRlbnRzTWFwLCBlbmROb2RlKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAobGV0IG5vZGUgPSBlbmROb2RlOyBub2RlICE9PSB2b2lkIDA7IG5vZGUgPSBwcmVjZWRlbnRzTWFwLmdldChub2RlKSkge1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGZpbmRTaG9ydGVzdFBhdGgoZ3JhcGgsIHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xuICBjb25zdCBwcmVjZWRlbnRzTWFwID0gYnVpbGRQcmVjZWRlbnRzTWFwKGdyYXBoLCBzdGFydE5vZGUsIGVuZE5vZGUpO1xuICByZXR1cm4gcHJlY2VkZW50c01hcCA/IGdldFBhdGhGcm9tUHJlY2VkZW50c01hcChwcmVjZWRlbnRzTWFwLCBlbmROb2RlKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGZpbmRJZGVhbE5vZGVTZWFyY2goe1xuICBwaG90b3MsXG4gIHRhcmdldFJvd0hlaWdodCxcbiAgY29udGFpbmVyV2lkdGhcbn0pIHtcbiAgY29uc3QgbWluUmF0aW8gPSBwaG90b3MucmVkdWNlKChhY2MsIHBob3RvKSA9PiBNYXRoLm1pbihyYXRpbyhwaG90byksIGFjYyksIE51bWJlci5NQVhfVkFMVUUpO1xuICByZXR1cm4gcm91bmQoY29udGFpbmVyV2lkdGggLyB0YXJnZXRSb3dIZWlnaHQgLyBtaW5SYXRpbykgKyAyO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uSGVpZ2h0KHJvdywgY29udGFpbmVyV2lkdGgsIHNwYWNpbmcsIHBhZGRpbmcpIHtcbiAgY29uc3Qgcm93V2lkdGggPSBjb250YWluZXJXaWR0aCAtIChyb3cubGVuZ3RoIC0gMSkgKiBzcGFjaW5nIC0gMiAqIHBhZGRpbmcgKiByb3cubGVuZ3RoO1xuICBjb25zdCB0b3RhbEFzcGVjdFJhdGlvID0gcm93LnJlZHVjZSgoYWNjLCBwaG90bykgPT4gYWNjICsgcmF0aW8ocGhvdG8pLCAwKTtcbiAgcmV0dXJuIHJvd1dpZHRoIC8gdG90YWxBc3BlY3RSYXRpbztcbn1cbmZ1bmN0aW9uIGNvc3QocGhvdG9zLCBpLCBqLCB3aWR0aCwgdGFyZ2V0Um93SGVpZ2h0LCBzcGFjaW5nLCBwYWRkaW5nKSB7XG4gIGNvbnN0IHJvdyA9IHBob3Rvcy5zbGljZShpLCBqKTtcbiAgY29uc3QgY29tbW9uSGVpZ2h0ID0gZ2V0Q29tbW9uSGVpZ2h0KHJvdywgd2lkdGgsIHNwYWNpbmcsIHBhZGRpbmcpO1xuICByZXR1cm4gY29tbW9uSGVpZ2h0ID4gMCA/IChjb21tb25IZWlnaHQgLSB0YXJnZXRSb3dIZWlnaHQpICoqIDIgKiByb3cubGVuZ3RoIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gbWFrZUdldFJvd05laWdoYm9ycyh7XG4gIHBob3RvcyxcbiAgbGF5b3V0T3B0aW9ucyxcbiAgdGFyZ2V0Um93SGVpZ2h0LFxuICBsaW1pdE5vZGVTZWFyY2gsXG4gIHJvd0NvbnN0cmFpbnRzXG59KSB7XG4gIHJldHVybiAobm9kZSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBjb250YWluZXJXaWR0aCwgc3BhY2luZywgcGFkZGluZyB9ID0gbGF5b3V0T3B0aW9ucztcbiAgICBjb25zdCByZXN1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICByZXN1bHRzLnNldChub2RlLCAwKTtcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IChfYSA9IHJvd0NvbnN0cmFpbnRzID09IG51bGwgPyB2b2lkIDAgOiByb3dDb25zdHJhaW50cy5taW5QaG90b3MpICE9IG51bGwgPyBfYSA6IDE7XG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gTWF0aC5taW4obGltaXROb2RlU2VhcmNoLCAoX2IgPSByb3dDb25zdHJhaW50cyA9PSBudWxsID8gdm9pZCAwIDogcm93Q29uc3RyYWludHMubWF4UGhvdG9zKSAhPSBudWxsID8gX2IgOiBJbmZpbml0eSk7XG4gICAgZm9yIChsZXQgaSA9IG5vZGUgKyBzdGFydE9mZnNldDsgaSA8IHBob3Rvcy5sZW5ndGggKyAxOyBpICs9IDEpIHtcbiAgICAgIGlmIChpIC0gbm9kZSA+IGVuZE9mZnNldCkgYnJlYWs7XG4gICAgICBjb25zdCBjdXJyZW50Q29zdCA9IGNvc3QocGhvdG9zLCBub2RlLCBpLCBjb250YWluZXJXaWR0aCwgdGFyZ2V0Um93SGVpZ2h0LCBzcGFjaW5nLCBwYWRkaW5nKTtcbiAgICAgIGlmIChjdXJyZW50Q29zdCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgIHJlc3VsdHMuc2V0KGksIGN1cnJlbnRDb3N0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlUm93c0xheW91dCh7XG4gIHBob3RvcyxcbiAgbGF5b3V0T3B0aW9uc1xufSkge1xuICBjb25zdCB7IHNwYWNpbmcsIHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoLCB0YXJnZXRSb3dIZWlnaHQsIHJvd0NvbnN0cmFpbnRzIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCBsaW1pdE5vZGVTZWFyY2ggPSBmaW5kSWRlYWxOb2RlU2VhcmNoKHsgcGhvdG9zLCBjb250YWluZXJXaWR0aCwgdGFyZ2V0Um93SGVpZ2h0IH0pO1xuICBjb25zdCBnZXROZWlnaGJvcnMgPSBtYWtlR2V0Um93TmVpZ2hib3JzKHtcbiAgICBwaG90b3MsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICB0YXJnZXRSb3dIZWlnaHQsXG4gICAgbGltaXROb2RlU2VhcmNoLFxuICAgIHJvd0NvbnN0cmFpbnRzXG4gIH0pO1xuICBjb25zdCBwYXRoID0gZmluZFNob3J0ZXN0UGF0aChnZXROZWlnaGJvcnMsIDAsIHBob3Rvcy5sZW5ndGgpO1xuICBpZiAocGF0aCA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBsYXlvdXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXRoLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qgcm93ID0gcGhvdG9zLm1hcCgocGhvdG8sIGluZGV4KSA9PiAoeyBwaG90bywgaW5kZXggfSkpLnNsaWNlKHBhdGhbaSAtIDFdLCBwYXRoW2ldKTtcbiAgICBjb25zdCBoZWlnaHQgPSBnZXRDb21tb25IZWlnaHQoXG4gICAgICByb3cubWFwKCh7IHBob3RvIH0pID0+IHBob3RvKSxcbiAgICAgIGNvbnRhaW5lcldpZHRoLFxuICAgICAgc3BhY2luZyxcbiAgICAgIHBhZGRpbmdcbiAgICApO1xuICAgIGxheW91dC5wdXNoKFxuICAgICAgcm93Lm1hcCgoeyBwaG90bywgaW5kZXggfSwgcGhvdG9JbmRleCkgPT4gKHtcbiAgICAgICAgcGhvdG8sXG4gICAgICAgIGxheW91dDoge1xuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICB3aWR0aDogaGVpZ2h0ICogcmF0aW8ocGhvdG8pLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHBob3RvSW5kZXgsXG4gICAgICAgICAgcGhvdG9zQ291bnQ6IHJvdy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbGF5b3V0O1xufVxuZnVuY3Rpb24gY2xzeCguLi5jbGFzc2VzKSB7XG4gIHJldHVybiBbLi4uY2xhc3Nlc10uZmlsdGVyKChjbHMpID0+IEJvb2xlYW4oY2xzKSkuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBjYWxjV2lkdGgoYmFzZSwgcGhvdG9MYXlvdXQsIGxheW91dE9wdGlvbnMpIHtcbiAgY29uc3QgeyB3aWR0aCwgcGhvdG9zQ291bnQgfSA9IHBob3RvTGF5b3V0O1xuICBjb25zdCB7IGxheW91dCwgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGggfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGNvdW50ID0gbGF5b3V0ID09PSBcInJvd3NcIiA/IHBob3Rvc0NvdW50IDogbGF5b3V0T3B0aW9ucy5jb2x1bW5zO1xuICBjb25zdCBnYXBzID0gc3BhY2luZyAqIChjb3VudCAtIDEpICsgMiAqIHBhZGRpbmcgKiBjb3VudDtcbiAgcmV0dXJuIGBjYWxjKCgke2Jhc2V9IC0gJHtnYXBzfXB4KSAvICR7cm91bmQoKGNvbnRhaW5lcldpZHRoIC0gZ2FwcykgLyB3aWR0aCwgNSl9KWA7XG59XG5mdW5jdGlvbiBjc3NQaG90b1dpZHRoKGxheW91dCwgbGF5b3V0T3B0aW9ucykge1xuICByZXR1cm4gbGF5b3V0T3B0aW9ucy5sYXlvdXQgIT09IFwicm93c1wiID8gYGNhbGMoMTAwJSAtICR7MiAqIGxheW91dE9wdGlvbnMucGFkZGluZ31weClgIDogY2FsY1dpZHRoKFwiMTAwJVwiLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU2l6ZXNWYWx1ZShzaXplLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIGNhbGNXaWR0aCgoX2IgPSAoX2EgPSBzaXplLm1hdGNoKC9eXFxzKmNhbGNcXCgoLiopXFwpXFxzKiQvKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzFdKSAhPSBudWxsID8gX2IgOiBzaXplLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc3JjU2V0QW5kU2l6ZXMocGhvdG8sIGxheW91dCwgbGF5b3V0T3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGxldCBzcmNTZXQ7XG4gIGxldCBzaXplcztcbiAgY29uc3QgaW1hZ2VzID0gcGhvdG8uc3JjU2V0IHx8IHBob3RvLmltYWdlcztcbiAgaWYgKGltYWdlcyAmJiBpbWFnZXMubGVuZ3RoID4gMCkge1xuICAgIHNyY1NldCA9IGltYWdlcy5jb25jYXQoXG4gICAgICAhaW1hZ2VzLmZpbmQoKHsgd2lkdGggfSkgPT4gd2lkdGggPT09IHBob3RvLndpZHRoKSA/IFt7IHNyYzogcGhvdG8uc3JjLCB3aWR0aDogcGhvdG8ud2lkdGgsIGhlaWdodDogcGhvdG8uaGVpZ2h0IH1dIDogW11cbiAgICApLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IGZpcnN0LndpZHRoIC0gc2Vjb25kLndpZHRoKS5tYXAoKGltYWdlKSA9PiBgJHtpbWFnZS5zcmN9ICR7aW1hZ2Uud2lkdGh9d2ApLmpvaW4oXCIsIFwiKTtcbiAgfVxuICBpZiAoKF9hID0gbGF5b3V0T3B0aW9ucy5zaXplcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNpemUpIHtcbiAgICBzaXplcyA9IChsYXlvdXRPcHRpb25zLnNpemVzLnNpemVzIHx8IFtdKS5tYXAoKHsgdmlld3BvcnQsIHNpemUgfSkgPT4gYCR7dmlld3BvcnR9ICR7Y2FsY3VsYXRlU2l6ZXNWYWx1ZShzaXplLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpfWApLmNvbmNhdChjYWxjdWxhdGVTaXplc1ZhbHVlKGxheW91dE9wdGlvbnMuc2l6ZXMuc2l6ZSwgbGF5b3V0LCBsYXlvdXRPcHRpb25zKSkuam9pbihcIiwgXCIpO1xuICB9IGVsc2Uge1xuICAgIHNpemVzID0gYCR7TWF0aC5jZWlsKGxheW91dC53aWR0aCAvIGxheW91dE9wdGlvbnMuY29udGFpbmVyV2lkdGggKiAxMDApfXZ3YDtcbiAgfVxuICByZXR1cm4geyBzcmNTZXQsIHNpemVzIH07XG59XG5mdW5jdGlvbiBQaG90b1JlbmRlcmVyKHByb3BzKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHsgcGhvdG8sIGxheW91dCwgbGF5b3V0T3B0aW9ucywgaW1hZ2VQcm9wczogeyBzdHlsZSwgY2xhc3NOYW1lLCAuLi5yZXN0SW1hZ2VQcm9wcyB9ID0ge30sIHJlbmRlclBob3RvIH0gPSBwcm9wcztcbiAgY29uc3QgeyBvbkNsaWNrIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCBpbWFnZVN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICBib3hTaXppbmc6IFwiY29udGVudC1ib3hcIixcbiAgICB3aWR0aDogY3NzUGhvdG9XaWR0aChsYXlvdXQsIGxheW91dE9wdGlvbnMpLFxuICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgYXNwZWN0UmF0aW86IGAke3Bob3RvLndpZHRofSAvICR7cGhvdG8uaGVpZ2h0fWAsXG4gICAgLi4ubGF5b3V0T3B0aW9ucy5wYWRkaW5nID8geyBwYWRkaW5nOiBgJHtsYXlvdXRPcHRpb25zLnBhZGRpbmd9cHhgIH0gOiBudWxsLFxuICAgIC4uLihsYXlvdXRPcHRpb25zLmxheW91dCA9PT0gXCJjb2x1bW5zXCIgfHwgbGF5b3V0T3B0aW9ucy5sYXlvdXQgPT09IFwibWFzb25yeVwiKSAmJiBsYXlvdXQucGhvdG9JbmRleCA8IGxheW91dC5waG90b3NDb3VudCAtIDEgPyB7IG1hcmdpbkJvdHRvbTogYCR7bGF5b3V0T3B0aW9ucy5zcGFjaW5nfXB4YCB9IDogbnVsbCxcbiAgICAuLi5vbkNsaWNrID8geyBjdXJzb3I6IFwicG9pbnRlclwiIH0gOiBudWxsLFxuICAgIC4uLnN0eWxlXG4gIH07XG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gb25DbGljayA/IChldmVudCkgPT4ge1xuICAgIG9uQ2xpY2soeyBldmVudCwgcGhvdG8sIGluZGV4OiBsYXlvdXQuaW5kZXggfSk7XG4gIH0gOiB2b2lkIDA7XG4gIGNvbnN0IGltYWdlUHJvcHMgPSB7XG4gICAgc3JjOiBwaG90by5zcmMsXG4gICAgYWx0OiAoX2EgPSBwaG90by5hbHQpICE9IG51bGwgPyBfYSA6IFwiXCIsXG4gICAgdGl0bGU6IHBob3RvLnRpdGxlLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgIHN0eWxlOiBpbWFnZVN0eWxlLFxuICAgIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LXBob3RvLWFsYnVtLS1waG90b1wiLCBjbGFzc05hbWUpLFxuICAgIGxvYWRpbmc6IFwibGF6eVwiLFxuICAgIGRlY29kaW5nOiBcImFzeW5jXCIsXG4gICAgLi4uc3JjU2V0QW5kU2l6ZXMocGhvdG8sIGxheW91dCwgbGF5b3V0T3B0aW9ucyksXG4gICAgLi4ucmVzdEltYWdlUHJvcHNcbiAgfTtcbiAgY29uc3QgcmVuZGVyRGVmYXVsdFBob3RvID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IHNyYywgYWx0LCBzcmNTZXQsIHNpemVzLCBzdHlsZTogdW53cmFwcGVkU3R5bGUsIC4uLnJlc3QgfSA9IGltYWdlUHJvcHM7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImltZ1wiLFxuICAgICAge1xuICAgICAgICBhbHQsXG4gICAgICAgIC4uLnNyY1NldCA/IHsgc3JjU2V0LCBzaXplcyB9IDogbnVsbCxcbiAgICAgICAgc3JjLFxuICAgICAgICBzdHlsZTogKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMud3JhcHBlZCkgPyB7IGRpc3BsYXk6IFwiYmxvY2tcIiwgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiIH0gOiB1bndyYXBwZWRTdHlsZSxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfVxuICAgICk7XG4gIH07XG4gIGNvbnN0IHdyYXBwZXJTdHlsZSA9ICgoeyBkaXNwbGF5LCBib3hTaXppbmcsIHdpZHRoLCBhc3BlY3RSYXRpbywgcGFkZGluZywgbWFyZ2luQm90dG9tLCBjdXJzb3IgfSkgPT4gKHtcbiAgICBkaXNwbGF5LFxuICAgIGJveFNpemluZyxcbiAgICB3aWR0aCxcbiAgICBhc3BlY3RSYXRpbyxcbiAgICBwYWRkaW5nLFxuICAgIG1hcmdpbkJvdHRvbSxcbiAgICBjdXJzb3JcbiAgfSkpKGltYWdlU3R5bGUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgKF9iID0gcmVuZGVyUGhvdG8gPT0gbnVsbCA/IHZvaWQgMCA6IHJlbmRlclBob3RvKHtcbiAgICBwaG90byxcbiAgICBsYXlvdXQsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICBpbWFnZVByb3BzLFxuICAgIHJlbmRlckRlZmF1bHRQaG90byxcbiAgICB3cmFwcGVyU3R5bGVcbiAgfSkpICE9IG51bGwgPyBfYiA6IHJlbmRlckRlZmF1bHRQaG90bygpKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJSb3dDb250YWluZXIoe1xuICByb3dDb250YWluZXJQcm9wcyxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyAuLi5yb3dDb250YWluZXJQcm9wcyB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBSb3dDb250YWluZXJSZW5kZXJlcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICByb3dJbmRleCxcbiAgICByb3dzQ291bnQsXG4gICAgcmVuZGVyUm93Q29udGFpbmVyLFxuICAgIHJvd0NvbnRhaW5lclByb3BzOiB7IHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3RSb3dDb250YWluZXJQcm9wcyB9ID0ge30sXG4gICAgY2hpbGRyZW5cbiAgfSA9IHByb3BzO1xuICBjb25zdCByb3dDb250YWluZXJQcm9wcyA9IHtcbiAgICBjbGFzc05hbWU6IGNsc3goXCJyZWFjdC1waG90by1hbGJ1bS0tcm93XCIsIGNsYXNzTmFtZSksXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgZmxleERpcmVjdGlvbjogXCJyb3dcIixcbiAgICAgIGZsZXhXcmFwOiBcIm5vd3JhcFwiLFxuICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0XCIsXG4gICAgICBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgICAuLi5yb3dJbmRleCA8IHJvd3NDb3VudCAtIDEgPyB7IG1hcmdpbkJvdHRvbTogYCR7bGF5b3V0T3B0aW9ucy5zcGFjaW5nfXB4YCB9IDogbnVsbCxcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICAuLi5yZXN0Um93Q29udGFpbmVyUHJvcHNcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIChyZW5kZXJSb3dDb250YWluZXIgIT0gbnVsbCA/IHJlbmRlclJvd0NvbnRhaW5lciA6IGRlZmF1bHRSZW5kZXJSb3dDb250YWluZXIpKHtcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJvd0luZGV4LFxuICAgIHJvd3NDb3VudCxcbiAgICByb3dDb250YWluZXJQcm9wcyxcbiAgICBjaGlsZHJlblxuICB9KSk7XG59XG5mdW5jdGlvbiBSb3dzTGF5b3V0KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBwaG90b3MsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICByZW5kZXJQaG90byxcbiAgICByZW5kZXJSb3dDb250YWluZXIsXG4gICAgY29tcG9uZW50c1Byb3BzOiB7IGltYWdlUHJvcHMsIHJvd0NvbnRhaW5lclByb3BzIH1cbiAgfSA9IHByb3BzO1xuICBjb25zdCByb3dzTGF5b3V0ID0gY29tcHV0ZVJvd3NMYXlvdXQoeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSk7XG4gIGlmICghcm93c0xheW91dCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByb3dzTGF5b3V0Lm1hcCgocm93LCByb3dJbmRleCkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBSb3dDb250YWluZXJSZW5kZXJlcixcbiAgICB7XG4gICAgICBrZXk6IGByb3ctJHtyb3dJbmRleH1gLFxuICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgIHJvd0luZGV4LFxuICAgICAgcm93c0NvdW50OiByb3dzTGF5b3V0Lmxlbmd0aCxcbiAgICAgIHJlbmRlclJvd0NvbnRhaW5lcixcbiAgICAgIHJvd0NvbnRhaW5lclByb3BzXG4gICAgfSxcbiAgICByb3cubWFwKCh7IHBob3RvLCBsYXlvdXQgfSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFBob3RvUmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGtleTogcGhvdG8ua2V5IHx8IHBob3RvLnNyYyxcbiAgICAgICAgcGhvdG8sXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgICAgcmVuZGVyUGhvdG8sXG4gICAgICAgIGltYWdlUHJvcHNcbiAgICAgIH1cbiAgICApKVxuICApKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2hvcnRlc3RQYXRoKGdyYXBoLCBwYXRoTGVuZ3RoLCBzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgY29uc3QgbWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgcXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBxdWV1ZS5hZGQoc3RhcnROb2RlKTtcbiAgZm9yIChsZXQgbGVuZ3RoID0gMDsgbGVuZ3RoIDwgcGF0aExlbmd0aDsgbGVuZ3RoICs9IDEpIHtcbiAgICBjb25zdCBjdXJyZW50UXVldWUgPSBbLi4ucXVldWUua2V5cygpXTtcbiAgICBxdWV1ZS5jbGVhcigpO1xuICAgIGN1cnJlbnRRdWV1ZS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBjb25zdCBhY2N1bXVsYXRlZFdlaWdodCA9IGxlbmd0aCA+IDAgPyBtYXRyaXguZ2V0KG5vZGUpW2xlbmd0aF0ud2VpZ2h0IDogMDtcbiAgICAgIGdyYXBoKG5vZGUpLmZvckVhY2goKHsgbmVpZ2hib3IsIHdlaWdodCB9KSA9PiB7XG4gICAgICAgIGxldCBwYXRocyA9IG1hdHJpeC5nZXQobmVpZ2hib3IpO1xuICAgICAgICBpZiAoIXBhdGhzKSB7XG4gICAgICAgICAgcGF0aHMgPSBbXTtcbiAgICAgICAgICBtYXRyaXguc2V0KG5laWdoYm9yLCBwYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3V2VpZ2h0ID0gYWNjdW11bGF0ZWRXZWlnaHQgKyB3ZWlnaHQ7XG4gICAgICAgIGNvbnN0IG5leHRQYXRoID0gcGF0aHNbbGVuZ3RoICsgMV07XG4gICAgICAgIGlmICghbmV4dFBhdGggfHwgbmV4dFBhdGgud2VpZ2h0ID4gbmV3V2VpZ2h0ICYmIChuZXh0UGF0aC53ZWlnaHQgLyBuZXdXZWlnaHQgPiAxLjAwMDEgfHwgbm9kZSA8IG5leHRQYXRoLm5vZGUpKSB7XG4gICAgICAgICAgcGF0aHNbbGVuZ3RoICsgMV0gPSB7IG5vZGUsIHdlaWdodDogbmV3V2VpZ2h0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IHBhdGhMZW5ndGggLSAxICYmIG5laWdoYm9yICE9PSBlbmROb2RlKSB7XG4gICAgICAgICAgcXVldWUuYWRkKG5laWdoYm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG1hdHJpeDtcbn1cbmZ1bmN0aW9uIHJlY29uc3RydWN0U2hvcnRlc3RQYXRoKG1hdHJpeCwgcGF0aExlbmd0aCwgZW5kTm9kZSkge1xuICBjb25zdCBwYXRoID0gW2VuZE5vZGVdO1xuICBmb3IgKGxldCBub2RlID0gZW5kTm9kZSwgbGVuZ3RoID0gcGF0aExlbmd0aDsgbGVuZ3RoID4gMDsgbGVuZ3RoIC09IDEpIHtcbiAgICBub2RlID0gbWF0cml4LmdldChub2RlKVtsZW5ndGhdLm5vZGU7XG4gICAgcGF0aC5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBwYXRoLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGZpbmRTaG9ydGVzdFBhdGhMZW5ndGhOKGdyYXBoLCBwYXRoTGVuZ3RoLCBzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuIHJlY29uc3RydWN0U2hvcnRlc3RQYXRoKGNvbXB1dGVTaG9ydGVzdFBhdGgoZ3JhcGgsIHBhdGhMZW5ndGgsIHN0YXJ0Tm9kZSwgZW5kTm9kZSksIHBhdGhMZW5ndGgsIGVuZE5vZGUpO1xufVxuZnVuY3Rpb24gbWFrZUdldENvbHVtbk5laWdoYm9ycyh7XG4gIHBob3RvcyxcbiAgc3BhY2luZyxcbiAgcGFkZGluZyxcbiAgdGFyZ2V0Q29sdW1uV2lkdGgsXG4gIHRhcmdldENvbHVtbkhlaWdodFxufSkge1xuICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgY3V0T2ZmSGVpZ2h0ID0gdGFyZ2V0Q29sdW1uSGVpZ2h0ICogMS41O1xuICAgIGxldCBoZWlnaHQgPSB0YXJnZXRDb2x1bW5XaWR0aCAvIHJhdGlvKHBob3Rvc1tub2RlXSkgKyAyICogcGFkZGluZztcbiAgICBmb3IgKGxldCBpID0gbm9kZSArIDE7IGkgPCBwaG90b3MubGVuZ3RoICsgMTsgaSArPSAxKSB7XG4gICAgICByZXN1bHRzLnB1c2goeyBuZWlnaGJvcjogaSwgd2VpZ2h0OiAodGFyZ2V0Q29sdW1uSGVpZ2h0IC0gaGVpZ2h0KSAqKiAyIH0pO1xuICAgICAgaWYgKGhlaWdodCA+IGN1dE9mZkhlaWdodCB8fCBpID09PSBwaG90b3MubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaGVpZ2h0ICs9IHRhcmdldENvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG9zW2ldKSArIHNwYWNpbmcgKyAyICogcGFkZGluZztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZENvbHVtbnNNb2RlbCh7XG4gIHBhdGgsXG4gIHBob3RvcyxcbiAgY29udGFpbmVyV2lkdGgsXG4gIGNvbHVtbnNHYXBzLFxuICBjb2x1bW5zUmF0aW9zLFxuICBzcGFjaW5nLFxuICBwYWRkaW5nXG59KSB7XG4gIGNvbnN0IGNvbHVtbnNNb2RlbCA9IFtdO1xuICBjb25zdCB0b3RhbFJhdGlvID0gY29sdW1uc1JhdGlvcy5yZWR1Y2UoKHRvdGFsLCBjb2x1bW5SYXRpbykgPT4gdG90YWwgKyBjb2x1bW5SYXRpbywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICBjb25zdCBjb2x1bW4gPSBwaG90b3MubWFwKChwaG90bywgaW5kZXgpID0+ICh7IHBob3RvLCBpbmRleCB9KSkuc2xpY2UocGF0aFtpXSwgcGF0aFtpICsgMV0pO1xuICAgIGNvbnN0IHRvdGFsQWRqdXN0ZWRHYXBzID0gY29sdW1uc1JhdGlvcy5yZWR1Y2UoXG4gICAgICAodG90YWwsIGNvbHVtblJhdGlvLCBpbmRleCkgPT4gdG90YWwgKyAoY29sdW1uc0dhcHNbaV0gLSBjb2x1bW5zR2Fwc1tpbmRleF0pICogY29sdW1uUmF0aW8sXG4gICAgICAwXG4gICAgKTtcbiAgICBjb25zdCBjb2x1bW5XaWR0aCA9IChjb250YWluZXJXaWR0aCAtIChwYXRoLmxlbmd0aCAtIDIpICogc3BhY2luZyAtIDIgKiAocGF0aC5sZW5ndGggLSAxKSAqIHBhZGRpbmcgLSB0b3RhbEFkanVzdGVkR2FwcykgKiBjb2x1bW5zUmF0aW9zW2ldIC8gdG90YWxSYXRpbztcbiAgICBjb2x1bW5zTW9kZWwucHVzaChcbiAgICAgIGNvbHVtbi5tYXAoKHsgcGhvdG8sIGluZGV4IH0sIHBob3RvSW5kZXgpID0+ICh7XG4gICAgICAgIHBob3RvLFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjb2x1bW5XaWR0aCAvIHJhdGlvKHBob3RvKSxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBwaG90b0luZGV4LFxuICAgICAgICAgIHBob3Rvc0NvdW50OiBjb2x1bW4ubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbHVtbnNNb2RlbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb2x1bW5zTW9kZWwoe1xuICBwaG90b3MsXG4gIGxheW91dE9wdGlvbnMsXG4gIHRhcmdldENvbHVtbldpZHRoXG59KSB7XG4gIGNvbnN0IHsgY29sdW1ucywgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGggfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGNvbHVtbnNHYXBzID0gW107XG4gIGNvbnN0IGNvbHVtbnNSYXRpb3MgPSBbXTtcbiAgaWYgKHBob3Rvcy5sZW5ndGggPD0gY29sdW1ucykge1xuICAgIGNvbnN0IGF2ZXJhZ2VSYXRpbyA9IHBob3Rvcy5sZW5ndGggPiAwID8gcGhvdG9zLnJlZHVjZSgoYWNjLCBwaG90bykgPT4gYWNjICsgcmF0aW8ocGhvdG8pLCAwKSAvIHBob3Rvcy5sZW5ndGggOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSArPSAxKSB7XG4gICAgICBjb2x1bW5zR2Fwc1tpXSA9IDIgKiBwYWRkaW5nO1xuICAgICAgY29sdW1uc1JhdGlvc1tpXSA9IGkgPCBwaG90b3MubGVuZ3RoID8gcmF0aW8ocGhvdG9zW2ldKSA6IGF2ZXJhZ2VSYXRpbztcbiAgICB9XG4gICAgY29uc3QgY29sdW1uc01vZGVsMiA9IGJ1aWxkQ29sdW1uc01vZGVsKHtcbiAgICAgIHBhdGg6IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHVtbnMgKyAxIH0pLm1hcCgoXywgaW5kZXgpID0+IE1hdGgubWluKGluZGV4LCBwaG90b3MubGVuZ3RoKSksXG4gICAgICBwaG90b3MsXG4gICAgICBjb2x1bW5zUmF0aW9zLFxuICAgICAgY29sdW1uc0dhcHMsXG4gICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgIHNwYWNpbmcsXG4gICAgICBwYWRkaW5nXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MsIGNvbHVtbnNNb2RlbDogY29sdW1uc01vZGVsMiB9O1xuICB9XG4gIGNvbnN0IHRhcmdldENvbHVtbkhlaWdodCA9IChwaG90b3MucmVkdWNlKChhY2MsIHBob3RvKSA9PiBhY2MgKyB0YXJnZXRDb2x1bW5XaWR0aCAvIHJhdGlvKHBob3RvKSwgMCkgKyBzcGFjaW5nICogKHBob3Rvcy5sZW5ndGggLSBjb2x1bW5zKSArIDIgKiBwYWRkaW5nICogcGhvdG9zLmxlbmd0aCkgLyBjb2x1bW5zO1xuICBjb25zdCBnZXROZWlnaGJvcnMgPSBtYWtlR2V0Q29sdW1uTmVpZ2hib3JzKHtcbiAgICBwaG90b3MsXG4gICAgdGFyZ2V0Q29sdW1uV2lkdGgsXG4gICAgdGFyZ2V0Q29sdW1uSGVpZ2h0LFxuICAgIHNwYWNpbmcsXG4gICAgcGFkZGluZ1xuICB9KTtcbiAgY29uc3QgcGF0aCA9IGZpbmRTaG9ydGVzdFBhdGhMZW5ndGhOKGdldE5laWdoYm9ycywgY29sdW1ucywgMCwgcGhvdG9zLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICBjb25zdCBjb2x1bW4gPSBwaG90b3Muc2xpY2UocGF0aFtpXSwgcGF0aFtpICsgMV0pO1xuICAgIGNvbHVtbnNHYXBzW2ldID0gc3BhY2luZyAqIChjb2x1bW4ubGVuZ3RoIC0gMSkgKyAyICogcGFkZGluZyAqIGNvbHVtbi5sZW5ndGg7XG4gICAgY29sdW1uc1JhdGlvc1tpXSA9IDEgLyBjb2x1bW4ucmVkdWNlKChhY2MsIHBob3RvKSA9PiBhY2MgKyAxIC8gcmF0aW8ocGhvdG8pLCAwKTtcbiAgfVxuICBjb25zdCBjb2x1bW5zTW9kZWwgPSBidWlsZENvbHVtbnNNb2RlbCh7XG4gICAgcGF0aCxcbiAgICBwaG90b3MsXG4gICAgY29sdW1uc1JhdGlvcyxcbiAgICBjb2x1bW5zR2FwcyxcbiAgICBjb250YWluZXJXaWR0aCxcbiAgICBzcGFjaW5nLFxuICAgIHBhZGRpbmdcbiAgfSk7XG4gIHJldHVybiB7IGNvbHVtbnNHYXBzLCBjb2x1bW5zUmF0aW9zLCBjb2x1bW5zTW9kZWwgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMYXlvdXQocHJvcHMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSA9IHByb3BzO1xuICBjb25zdCB7IGNvbHVtbnMsIHNwYWNpbmcsIHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCB0YXJnZXRDb2x1bW5XaWR0aCA9IChjb250YWluZXJXaWR0aCAtIHNwYWNpbmcgKiAoY29sdW1ucyAtIDEpIC0gMiAqIHBhZGRpbmcgKiBjb2x1bW5zKSAvIGNvbHVtbnM7XG4gIGNvbnN0IHsgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MsIGNvbHVtbnNNb2RlbCB9ID0gY29tcHV0ZUNvbHVtbnNNb2RlbCh7XG4gICAgcGhvdG9zLFxuICAgIGxheW91dE9wdGlvbnMsXG4gICAgdGFyZ2V0Q29sdW1uV2lkdGhcbiAgfSk7XG4gIGlmIChjb2x1bW5zTW9kZWwuZmluZEluZGV4KFxuICAgIChjb2x1bW5Nb2RlbCkgPT4gY29sdW1uTW9kZWwuZmluZEluZGV4KCh7IGxheW91dDogeyB3aWR0aCwgaGVpZ2h0IH0gfSkgPT4gd2lkdGggPCAwIHx8IGhlaWdodCA8IDApID49IDBcbiAgKSA+PSAwKSB7XG4gICAgaWYgKGNvbHVtbnMgPiAxKSB7XG4gICAgICByZXR1cm4gY29tcHV0ZUxheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9uczogeyAuLi5sYXlvdXRPcHRpb25zLCBjb2x1bW5zOiBjb2x1bW5zIC0gMSB9IH0pO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7IGNvbHVtbnNNb2RlbCwgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb2x1bW5zTGF5b3V0KHtcbiAgcGhvdG9zLFxuICBsYXlvdXRPcHRpb25zXG59KSB7XG4gIHJldHVybiBjb21wdXRlTGF5b3V0KHsgcGhvdG9zLCBsYXlvdXRPcHRpb25zIH0pO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNvbHVtbkNvbnRhaW5lcih7XG4gIGNvbHVtbkNvbnRhaW5lclByb3BzLFxuICBjaGlsZHJlblxufSkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLmNvbHVtbkNvbnRhaW5lclByb3BzIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIGNzc0NvbHVtbldpZHRoKHByb3BzKSB7XG4gIGNvbnN0IHsgbGF5b3V0T3B0aW9ucywgY29sdW1uSW5kZXgsIGNvbHVtbnNDb3VudCwgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MgfSA9IHByb3BzO1xuICBjb25zdCB7IGxheW91dCwgc3BhY2luZywgcGFkZGluZyB9ID0gbGF5b3V0T3B0aW9ucztcbiAgaWYgKGxheW91dCA9PT0gXCJtYXNvbnJ5XCIgfHwgIWNvbHVtbnNHYXBzIHx8ICFjb2x1bW5zUmF0aW9zKSB7XG4gICAgcmV0dXJuIGBjYWxjKCgxMDAlIC0gJHtzcGFjaW5nICogKGNvbHVtbnNDb3VudCAtIDEpfXB4KSAvICR7Y29sdW1uc0NvdW50fSlgO1xuICB9XG4gIGNvbnN0IHRvdGFsUmF0aW8gPSBjb2x1bW5zUmF0aW9zLnJlZHVjZSgoYWNjLCByYXRpbzIpID0+IGFjYyArIHJhdGlvMiwgMCk7XG4gIGNvbnN0IHRvdGFsQWRqdXN0ZWRHYXBzID0gY29sdW1uc1JhdGlvcy5yZWR1Y2UoXG4gICAgKGFjYywgcmF0aW8yLCBpbmRleCkgPT4gYWNjICsgKGNvbHVtbnNHYXBzW2NvbHVtbkluZGV4XSAtIGNvbHVtbnNHYXBzW2luZGV4XSkgKiByYXRpbzIsXG4gICAgMFxuICApO1xuICByZXR1cm4gYGNhbGMoKDEwMCUgLSAke3JvdW5kKFxuICAgIChjb2x1bW5zQ291bnQgLSAxKSAqIHNwYWNpbmcgKyAyICogY29sdW1uc0NvdW50ICogcGFkZGluZyArIHRvdGFsQWRqdXN0ZWRHYXBzLFxuICAgIDNcbiAgKX1weCkgKiAke3JvdW5kKGNvbHVtbnNSYXRpb3NbY29sdW1uSW5kZXhdIC8gdG90YWxSYXRpbywgNSl9ICsgJHsyICogcGFkZGluZ31weClgO1xufVxuZnVuY3Rpb24gQ29sdW1uQ29udGFpbmVyUmVuZGVyZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGxheW91dE9wdGlvbnMsXG4gICAgcmVuZGVyQ29sdW1uQ29udGFpbmVyLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbHVtbkNvbnRhaW5lclByb3BzOiB7IHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3RDb2x1bW5Db250YWluZXJQcm9wcyB9ID0ge30sXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbHVtbkNvbnRhaW5lclByb3BzID0ge1xuICAgIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LXBob3RvLWFsYnVtLS1jb2x1bW5cIiwgY2xhc3NOYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIixcbiAgICAgIHdpZHRoOiBjc3NDb2x1bW5XaWR0aChwcm9wcyksXG4gICAgICBqdXN0aWZ5Q29udGVudDogbGF5b3V0T3B0aW9ucy5sYXlvdXQgPT09IFwiY29sdW1uc1wiID8gXCJzcGFjZS1iZXR3ZWVuXCIgOiBcImZsZXgtc3RhcnRcIixcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICAuLi5yZXN0Q29sdW1uQ29udGFpbmVyUHJvcHNcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIChyZW5kZXJDb2x1bW5Db250YWluZXIgIT0gbnVsbCA/IHJlbmRlckNvbHVtbkNvbnRhaW5lciA6IGRlZmF1bHRSZW5kZXJDb2x1bW5Db250YWluZXIpKHtcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIGNvbHVtbkNvbnRhaW5lclByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIC4uLnJlc3RcbiAgfSkpO1xufVxuZnVuY3Rpb24gQ29sdW1uc0xheW91dChwcm9wcykge1xuICBjb25zdCB7XG4gICAgcGhvdG9zLFxuICAgIGxheW91dE9wdGlvbnMsXG4gICAgcmVuZGVyUGhvdG8sXG4gICAgcmVuZGVyQ29sdW1uQ29udGFpbmVyLFxuICAgIGNvbXBvbmVudHNQcm9wczogeyBpbWFnZVByb3BzLCBjb2x1bW5Db250YWluZXJQcm9wcyB9XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgY29sdW1uc0xheW91dCA9IGNvbXB1dGVDb2x1bW5zTGF5b3V0KHsgcGhvdG9zLCBsYXlvdXRPcHRpb25zIH0pO1xuICBpZiAoIWNvbHVtbnNMYXlvdXQpIHJldHVybiBudWxsO1xuICBjb25zdCB7IGNvbHVtbnNNb2RlbCwgY29sdW1uc1JhdGlvcywgY29sdW1uc0dhcHMgfSA9IGNvbHVtbnNMYXlvdXQ7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb2x1bW5zTW9kZWwubWFwKChjb2x1bW4sIGNvbHVtbkluZGV4KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIENvbHVtbkNvbnRhaW5lclJlbmRlcmVyLFxuICAgIHtcbiAgICAgIGtleTogYGNvbHVtbi0ke2NvbHVtbkluZGV4fWAsXG4gICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgY29sdW1uSW5kZXgsXG4gICAgICBjb2x1bW5zQ291bnQ6IGNvbHVtbnNNb2RlbC5sZW5ndGgsXG4gICAgICBjb2x1bW5zR2FwcyxcbiAgICAgIGNvbHVtbnNSYXRpb3MsXG4gICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICBjb2x1bW5Db250YWluZXJQcm9wc1xuICAgIH0sXG4gICAgY29sdW1uLm1hcCgoeyBwaG90bywgbGF5b3V0IH0pID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBQaG90b1JlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBrZXk6IHBob3RvLmtleSB8fCBwaG90by5zcmMsXG4gICAgICAgIHBob3RvLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIHJlbmRlclBob3RvLFxuICAgICAgICBpbWFnZVByb3BzXG4gICAgICB9XG4gICAgKSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1hc29ucnlMYXlvdXQocHJvcHMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSA9IHByb3BzO1xuICBjb25zdCB7IGNvbHVtbnMsIHNwYWNpbmcsIHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCBjb2x1bW5XaWR0aCA9IChjb250YWluZXJXaWR0aCAtIHNwYWNpbmcgKiAoY29sdW1ucyAtIDEpIC0gMiAqIHBhZGRpbmcgKiBjb2x1bW5zKSAvIGNvbHVtbnM7XG4gIGlmIChjb2x1bW5XaWR0aCA8PSAwKSB7XG4gICAgcmV0dXJuIGNvbHVtbnMgPiAxID8gY29tcHV0ZU1hc29ucnlMYXlvdXQoe1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBsYXlvdXRPcHRpb25zOiB7IC4uLmxheW91dE9wdGlvbnMsIGNvbHVtbnM6IGNvbHVtbnMgLSAxIH1cbiAgICB9KSA6IHZvaWQgMDtcbiAgfVxuICBjb25zdCBjb2x1bW5zQ3VycmVudFRvcFBvc2l0aW9ucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkgKz0gMSkge1xuICAgIGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zW2ldID0gMDtcbiAgfVxuICBjb25zdCBjb2x1bW5zTW9kZWwgPSBwaG90b3MucmVkdWNlKFxuICAgIChtb2RlbCwgcGhvdG8sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzaG9ydGVzdENvbHVtbiA9IGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zLnJlZHVjZShcbiAgICAgICAgKGN1cnJlbnRTaG9ydGVzdENvbHVtbiwgaXRlbSwgaSkgPT4gaXRlbSA8IGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zW2N1cnJlbnRTaG9ydGVzdENvbHVtbl0gLSAxID8gaSA6IGN1cnJlbnRTaG9ydGVzdENvbHVtbixcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zW3Nob3J0ZXN0Q29sdW1uXSA9IGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zW3Nob3J0ZXN0Q29sdW1uXSArIGNvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG8pICsgc3BhY2luZyArIDIgKiBwYWRkaW5nO1xuICAgICAgbW9kZWxbc2hvcnRlc3RDb2x1bW5dLnB1c2goeyBwaG90bywgaW5kZXggfSk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcbiAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2x1bW5zIH0pLm1hcCgoKSA9PiBbXSlcbiAgKTtcbiAgcmV0dXJuIGNvbHVtbnNNb2RlbC5tYXAoXG4gICAgKGNvbHVtbikgPT4gY29sdW1uLm1hcCgoeyBwaG90bywgaW5kZXggfSwgcGhvdG9JbmRleCkgPT4gKHtcbiAgICAgIHBob3RvLFxuICAgICAgbGF5b3V0OiB7XG4gICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjb2x1bW5XaWR0aCAvIHJhdGlvKHBob3RvKSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHBob3RvSW5kZXgsXG4gICAgICAgIHBob3Rvc0NvdW50OiBjb2x1bW4ubGVuZ3RoXG4gICAgICB9XG4gICAgfSkpXG4gICk7XG59XG5mdW5jdGlvbiBNYXNvbnJ5TGF5b3V0KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBwaG90b3MsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICByZW5kZXJQaG90byxcbiAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgY29tcG9uZW50c1Byb3BzOiB7IGltYWdlUHJvcHMsIGNvbHVtbkNvbnRhaW5lclByb3BzIH1cbiAgfSA9IHByb3BzO1xuICBjb25zdCBtYXNvbnJ5TGF5b3V0ID0gY29tcHV0ZU1hc29ucnlMYXlvdXQoeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSk7XG4gIGlmICghbWFzb25yeUxheW91dCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBtYXNvbnJ5TGF5b3V0Lm1hcCgoY29sdW1uLCBjb2x1bW5JbmRleCkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBDb2x1bW5Db250YWluZXJSZW5kZXJlcixcbiAgICB7XG4gICAgICBrZXk6IGBtYXNvbnJ5LWNvbHVtbi0ke2NvbHVtbkluZGV4fWAsXG4gICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgY29sdW1uc0NvdW50OiBtYXNvbnJ5TGF5b3V0Lmxlbmd0aCxcbiAgICAgIGNvbHVtbkluZGV4LFxuICAgICAgcmVuZGVyQ29sdW1uQ29udGFpbmVyLFxuICAgICAgY29sdW1uQ29udGFpbmVyUHJvcHNcbiAgICB9LFxuICAgIGNvbHVtbi5tYXAoKHsgcGhvdG8sIGxheW91dCB9KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgUGhvdG9SZW5kZXJlcixcbiAgICAgIHtcbiAgICAgICAga2V5OiBwaG90by5rZXkgfHwgcGhvdG8uc3JjLFxuICAgICAgICBwaG90byxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgICByZW5kZXJQaG90byxcbiAgICAgICAgaW1hZ2VQcm9wc1xuICAgICAgfVxuICAgICkpXG4gICkpKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDb250YWluZXIoeyBjb250YWluZXJQcm9wcywgY2hpbGRyZW4sIGNvbnRhaW5lclJlZiB9KSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBjb250YWluZXJSZWYsIC4uLmNvbnRhaW5lclByb3BzIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIENvbnRhaW5lclJlbmRlcmVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBsYXlvdXQsXG4gICAgcmVuZGVyQ29udGFpbmVyLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lclJlZixcbiAgICBjb250YWluZXJQcm9wczogeyBzdHlsZSwgY2xhc3NOYW1lLCAuLi5yZXN0Q29udGFpbmVyUHJvcHMgfSA9IHt9XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgY29udGFpbmVyUHJvcHMgPSB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KFwicmVhY3QtcGhvdG8tYWxidW1cIiwgYHJlYWN0LXBob3RvLWFsYnVtLS0ke2xheW91dH1gLCBjbGFzc05hbWUpLFxuICAgIHN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgIGZsZXhXcmFwOiBcIm5vd3JhcFwiLFxuICAgICAganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLFxuICAgICAgZmxleERpcmVjdGlvbjogbGF5b3V0ID09PSBcInJvd3NcIiA/IFwiY29sdW1uXCIgOiBcInJvd1wiLFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIC4uLnJlc3RDb250YWluZXJQcm9wc1xuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgKHJlbmRlckNvbnRhaW5lciAhPSBudWxsID8gcmVuZGVyQ29udGFpbmVyIDogZGVmYXVsdFJlbmRlckNvbnRhaW5lcikoe1xuICAgIGNvbnRhaW5lclByb3BzLFxuICAgIGNvbnRhaW5lclJlZixcbiAgICBsYXlvdXQsXG4gICAgY2hpbGRyZW5cbiAgfSkpO1xufVxuZnVuY3Rpb24gdXNlQXJyYXkoYXJyYXkpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKGFycmF5KTtcbiAgaWYgKCFhcnJheSB8fCAhcmVmLmN1cnJlbnQgfHwgYXJyYXkuam9pbigpICE9PSByZWYuY3VycmVudC5qb2luKCkpIHtcbiAgICByZWYuY3VycmVudCA9IGFycmF5O1xuICB9XG4gIHJldHVybiByZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5lcldpZHRoUmVkdWNlcihzdGF0ZSwgeyBuZXdDb250YWluZXJXaWR0aCwgbmV3U2Nyb2xsYmFyV2lkdGggfSkge1xuICBjb25zdCB7IGNvbnRhaW5lcldpZHRoLCBzY3JvbGxiYXJXaWR0aCB9ID0gc3RhdGU7XG4gIGlmIChjb250YWluZXJXaWR0aCAhPT0gdm9pZCAwICYmIHNjcm9sbGJhcldpZHRoICE9PSB2b2lkIDAgJiYgbmV3Q29udGFpbmVyV2lkdGggIT09IHZvaWQgMCAmJiBuZXdTY3JvbGxiYXJXaWR0aCAhPT0gdm9pZCAwICYmIG5ld0NvbnRhaW5lcldpZHRoID4gY29udGFpbmVyV2lkdGggJiYgbmV3Q29udGFpbmVyV2lkdGggLSBjb250YWluZXJXaWR0aCA8PSAyMCAmJiBuZXdTY3JvbGxiYXJXaWR0aCA8IHNjcm9sbGJhcldpZHRoKSB7XG4gICAgcmV0dXJuIHsgY29udGFpbmVyV2lkdGgsIHNjcm9sbGJhcldpZHRoOiBuZXdTY3JvbGxiYXJXaWR0aCB9O1xuICB9XG4gIHJldHVybiBjb250YWluZXJXaWR0aCAhPT0gbmV3Q29udGFpbmVyV2lkdGggfHwgc2Nyb2xsYmFyV2lkdGggIT09IG5ld1Njcm9sbGJhcldpZHRoID8geyBjb250YWluZXJXaWR0aDogbmV3Q29udGFpbmVyV2lkdGgsIHNjcm9sbGJhcldpZHRoOiBuZXdTY3JvbGxiYXJXaWR0aCB9IDogc3RhdGU7XG59XG5mdW5jdGlvbiByZXNvbHZlQ29udGFpbmVyV2lkdGgoZWwsIGJyZWFrcG9pbnRzMikge1xuICBsZXQgd2lkdGggPSBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuY2xpZW50V2lkdGg7XG4gIGlmICh3aWR0aCAhPT0gdm9pZCAwICYmIGJyZWFrcG9pbnRzMiAmJiBicmVha3BvaW50czIubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHNvcnRlZCA9IFsuLi5icmVha3BvaW50czIuZmlsdGVyKCh4KSA9PiB4ID4gMCldLnNvcnQoKGEsIGIpID0+IGIgLSBhKTtcbiAgICBzb3J0ZWQucHVzaChNYXRoLmZsb29yKHNvcnRlZFtzb3J0ZWQubGVuZ3RoIC0gMV0gLyAyKSk7XG4gICAgY29uc3QgdGhyZXNob2xkID0gd2lkdGg7XG4gICAgd2lkdGggPSBzb3J0ZWQuZmluZCgoYnJlYWtwb2ludCwgaW5kZXgpID0+IGJyZWFrcG9pbnQgPD0gdGhyZXNob2xkIHx8IGluZGV4ID09PSBzb3J0ZWQubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHdpZHRoO1xufVxuZnVuY3Rpb24gdXNlQ29udGFpbmVyV2lkdGgoYnJlYWtwb2ludHMyLCBkZWZhdWx0Q29udGFpbmVyV2lkdGgpIHtcbiAgY29uc3QgW3sgY29udGFpbmVyV2lkdGggfSwgZGlzcGF0Y2hdID0gUmVhY3QudXNlUmVkdWNlcihjb250YWluZXJXaWR0aFJlZHVjZXIsIHtcbiAgICBjb250YWluZXJXaWR0aDogZGVmYXVsdENvbnRhaW5lcldpZHRoXG4gIH0pO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG9ic2VydmVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChub2RlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBvYnNlcnZlclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgb2JzZXJ2ZXJSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIGNvbnN0IHVwZGF0ZVdpZHRoID0gKCkgPT4gZGlzcGF0Y2goe1xuICAgICAgICBuZXdDb250YWluZXJXaWR0aDogcmVzb2x2ZUNvbnRhaW5lcldpZHRoKHJlZi5jdXJyZW50LCBicmVha3BvaW50czIpLFxuICAgICAgICBuZXdTY3JvbGxiYXJXaWR0aDogd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlV2lkdGgoKTtcbiAgICAgIGlmIChub2RlICYmIHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKHVwZGF0ZVdpZHRoKTtcbiAgICAgICAgb2JzZXJ2ZXJSZWYuY3VycmVudC5vYnNlcnZlKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2JyZWFrcG9pbnRzMl1cbiAgKTtcbiAgcmV0dXJuIHsgY29udGFpbmVyUmVmLCBjb250YWluZXJXaWR0aCB9O1xufVxuY29uc3QgYnJlYWtwb2ludHMgPSBPYmplY3QuZnJlZXplKFsxMjAwLCA2MDAsIDMwMCwgMF0pO1xuZnVuY3Rpb24gdW53cmFwKHZhbHVlLCBhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUoYXJnKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gdW53cmFwUGFyYW1ldGVyKHZhbHVlLCBjb250YWluZXJXaWR0aCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiID8gdW53cmFwKHZhbHVlLCBjb250YWluZXJXaWR0aCkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzZWxlY3RSZXNwb25zaXZlVmFsdWUodmFsdWVzLCBjb250YWluZXJXaWR0aCkge1xuICBjb25zdCBpbmRleCA9IGJyZWFrcG9pbnRzLmZpbmRJbmRleCgoYnJlYWtwb2ludCkgPT4gYnJlYWtwb2ludCA8PSBjb250YWluZXJXaWR0aCk7XG4gIHJldHVybiB1bndyYXAodmFsdWVzW2luZGV4ID49IDAgPyBpbmRleCA6IDBdLCBjb250YWluZXJXaWR0aCk7XG59XG5mdW5jdGlvbiByZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlcihwYXJhbWV0ZXIsIGNvbnRhaW5lcldpZHRoLCB2YWx1ZXMsIG1pblZhbHVlID0gMCkge1xuICBjb25zdCB2YWx1ZSA9IHVud3JhcFBhcmFtZXRlcihwYXJhbWV0ZXIsIGNvbnRhaW5lcldpZHRoKTtcbiAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5tYXgodmFsdWUgPT09IHZvaWQgMCA/IHNlbGVjdFJlc3BvbnNpdmVWYWx1ZSh2YWx1ZXMsIGNvbnRhaW5lcldpZHRoKSA6IHZhbHVlLCBtaW5WYWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUxheW91dE9wdGlvbnMoe1xuICBsYXlvdXQsXG4gIG9uQ2xpY2ssXG4gIGNvbnRhaW5lcldpZHRoLFxuICB0YXJnZXRSb3dIZWlnaHQsXG4gIHJvd0NvbnN0cmFpbnRzLFxuICBjb2x1bW5zLFxuICBzcGFjaW5nLFxuICBwYWRkaW5nLFxuICBzaXplc1xufSkge1xuICByZXR1cm4ge1xuICAgIGxheW91dCxcbiAgICBvbkNsaWNrLFxuICAgIGNvbnRhaW5lcldpZHRoLFxuICAgIGNvbHVtbnM6IHJlc29sdmVSZXNwb25zaXZlUGFyYW1ldGVyKGNvbHVtbnMsIGNvbnRhaW5lcldpZHRoLCBbNSwgNCwgMywgMl0sIDEpLFxuICAgIHNwYWNpbmc6IHJlc29sdmVSZXNwb25zaXZlUGFyYW1ldGVyKHNwYWNpbmcsIGNvbnRhaW5lcldpZHRoLCBbMjAsIDE1LCAxMCwgNV0pLFxuICAgIHBhZGRpbmc6IHJlc29sdmVSZXNwb25zaXZlUGFyYW1ldGVyKHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoLCBbMCwgMCwgMCwgMCwgMF0pLFxuICAgIHRhcmdldFJvd0hlaWdodDogcmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIodGFyZ2V0Um93SGVpZ2h0LCBjb250YWluZXJXaWR0aCwgW1xuICAgICAgKHcpID0+IHcgLyA1LFxuICAgICAgKHcpID0+IHcgLyA0LFxuICAgICAgKHcpID0+IHcgLyAzLFxuICAgICAgKHcpID0+IHcgLyAyXG4gICAgXSksXG4gICAgcm93Q29uc3RyYWludHM6IHVud3JhcFBhcmFtZXRlcihyb3dDb25zdHJhaW50cywgY29udGFpbmVyV2lkdGgpLFxuICAgIHNpemVzXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50c1Byb3BzKHByb3BzLCBjb250YWluZXJXaWR0aCwgbGF5b3V0T3B0aW9ucykge1xuICBjb25zdCB7IHBob3RvcywgY29tcG9uZW50c1Byb3BzOiBjb21wb25lbnRzUHJvcHNQcm9wIH0gPSBwcm9wcztcbiAgY29uc3QgY29tcG9uZW50c1Byb3BzID0gdW53cmFwKGNvbXBvbmVudHNQcm9wc1Byb3AsIGNvbnRhaW5lcldpZHRoKSB8fCB7fTtcbiAgaWYgKGxheW91dE9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGxheW91dCwgc3BhY2luZywgcGFkZGluZywgcm93Q29uc3RyYWludHMgfSA9IGxheW91dE9wdGlvbnM7XG4gICAgaWYgKGxheW91dCA9PT0gXCJyb3dzXCIpIHtcbiAgICAgIGNvbnN0IHsgc2luZ2xlUm93TWF4SGVpZ2h0IH0gPSByb3dDb25zdHJhaW50cyB8fCB7fTtcbiAgICAgIGlmIChzaW5nbGVSb3dNYXhIZWlnaHQpIHtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSBNYXRoLmZsb29yKFxuICAgICAgICAgIHBob3Rvcy5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjLCB7IHdpZHRoLCBoZWlnaHQgfSkgPT4gYWNjICsgd2lkdGggLyBoZWlnaHQgKiBzaW5nbGVSb3dNYXhIZWlnaHQgLSAyICogcGFkZGluZyxcbiAgICAgICAgICAgIHBhZGRpbmcgKiBwaG90b3MubGVuZ3RoICogMiArIHNwYWNpbmcgKiAocGhvdG9zLmxlbmd0aCAtIDEpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBpZiAobWF4V2lkdGggPiAwKSB7XG4gICAgICAgICAgY29tcG9uZW50c1Byb3BzLmNvbnRhaW5lclByb3BzID0gY29tcG9uZW50c1Byb3BzLmNvbnRhaW5lclByb3BzIHx8IHt9O1xuICAgICAgICAgIGNvbXBvbmVudHNQcm9wcy5jb250YWluZXJQcm9wcy5zdHlsZSA9IHsgbWF4V2lkdGgsIC4uLmNvbXBvbmVudHNQcm9wcy5jb250YWluZXJQcm9wcy5zdHlsZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wb25lbnRzUHJvcHM7XG59XG5mdW5jdGlvbiByZW5kZXJMYXlvdXQocHJvcHMsIGNvbXBvbmVudHNQcm9wcywgbGF5b3V0T3B0aW9ucykge1xuICBjb25zdCB7IHBob3RvcywgbGF5b3V0LCByZW5kZXJQaG90bywgcmVuZGVyUm93Q29udGFpbmVyLCByZW5kZXJDb2x1bW5Db250YWluZXIgfSA9IHByb3BzO1xuICBjb25zdCBjb21tb25MYXlvdXRQcm9wcyA9IHsgcGhvdG9zLCByZW5kZXJQaG90bywgY29tcG9uZW50c1Byb3BzIH07XG4gIGlmIChsYXlvdXQgPT09IFwicm93c1wiKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBSb3dzTGF5b3V0LFxuICAgICAge1xuICAgICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgICByZW5kZXJSb3dDb250YWluZXIsXG4gICAgICAgIC4uLmNvbW1vbkxheW91dFByb3BzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAobGF5b3V0ID09PSBcImNvbHVtbnNcIikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgQ29sdW1uc0xheW91dCxcbiAgICAgIHtcbiAgICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgICAgcmVuZGVyQ29sdW1uQ29udGFpbmVyLFxuICAgICAgICAuLi5jb21tb25MYXlvdXRQcm9wc1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgTWFzb25yeUxheW91dCxcbiAgICB7XG4gICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgcmVuZGVyQ29sdW1uQ29udGFpbmVyLFxuICAgICAgLi4uY29tbW9uTGF5b3V0UHJvcHNcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBQaG90b0FsYnVtKHByb3BzKSB7XG4gIGNvbnN0IHsgcGhvdG9zLCBsYXlvdXQsIHJlbmRlckNvbnRhaW5lciwgZGVmYXVsdENvbnRhaW5lcldpZHRoLCBicmVha3BvaW50czogYnJlYWtwb2ludHMyIH0gPSBwcm9wcztcbiAgY29uc3QgeyBjb250YWluZXJSZWYsIGNvbnRhaW5lcldpZHRoIH0gPSB1c2VDb250YWluZXJXaWR0aCh1c2VBcnJheShicmVha3BvaW50czIpLCBkZWZhdWx0Q29udGFpbmVyV2lkdGgpO1xuICBpZiAoIWxheW91dCB8fCAhW1wicm93c1wiLCBcImNvbHVtbnNcIiwgXCJtYXNvbnJ5XCJdLmluY2x1ZGVzKGxheW91dCkgfHwgIUFycmF5LmlzQXJyYXkocGhvdG9zKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGxheW91dE9wdGlvbnMgPSBjb250YWluZXJXaWR0aCA/IHJlc29sdmVMYXlvdXRPcHRpb25zKHsgY29udGFpbmVyV2lkdGgsIC4uLnByb3BzIH0pIDogdm9pZCAwO1xuICBjb25zdCBjb21wb25lbnRzUHJvcHMgPSByZXNvbHZlQ29tcG9uZW50c1Byb3BzKHByb3BzLCBjb250YWluZXJXaWR0aCwgbGF5b3V0T3B0aW9ucyk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIENvbnRhaW5lclJlbmRlcmVyLFxuICAgIHtcbiAgICAgIGxheW91dCxcbiAgICAgIGNvbnRhaW5lclJlZixcbiAgICAgIHJlbmRlckNvbnRhaW5lcixcbiAgICAgIGNvbnRhaW5lclByb3BzOiBjb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHNcbiAgICB9LFxuICAgIGxheW91dE9wdGlvbnMgJiYgcmVuZGVyTGF5b3V0KHByb3BzLCBjb21wb25lbnRzUHJvcHMsIGxheW91dE9wdGlvbnMpXG4gICk7XG59XG5leHBvcnQge1xuICBQaG90b0FsYnVtLFxuICBQaG90b0FsYnVtIGFzIGRlZmF1bHQsXG4gIGNvbXB1dGVDb2x1bW5zTGF5b3V0IGFzIHVuc3RhYmxlX2NvbXB1dGVDb2x1bW5zTGF5b3V0LFxuICBjb21wdXRlTWFzb25yeUxheW91dCBhcyB1bnN0YWJsZV9jb21wdXRlTWFzb25yeUxheW91dCxcbiAgY29tcHV0ZVJvd3NMYXlvdXQgYXMgdW5zdGFibGVfY29tcHV0ZVJvd3NMYXlvdXRcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJyYXRpbyIsIndpZHRoIiwiaGVpZ2h0Iiwicm91bmQiLCJ2YWx1ZSIsImRlY2ltYWxzIiwiZmFjdG9yIiwiTWF0aCIsIk51bWJlciIsIkVQU0lMT04iLCJyYW5raW5nRnVuY3Rpb25Db21wYXJhdG9yIiwicmFuayIsImEiLCJiIiwiTWluSGVhcCIsImNvbnN0cnVjdG9yIiwiY29tcGFyYXRvciIsImhlYXAiLCJuIiwiZ3JlYXRlciIsImkiLCJqIiwic3dhcCIsInRlbXAiLCJzd2ltIiwiayIsImsyIiwiZmxvb3IiLCJzaW5rIiwicHVzaCIsImVsZW1lbnQiLCJwb3AiLCJtYXgiLCJzaXplIiwiYnVpbGRQcmVjZWRlbnRzTWFwIiwiZ3JhcGgiLCJzdGFydE5vZGUiLCJlbmROb2RlIiwicHJlY2VkZW50c01hcCIsIk1hcCIsInZpc2l0ZWQiLCJTZXQiLCJzdG9yZWRTaG9ydGVzdFBhdGhzIiwic2V0IiwicXVldWUiLCJlbCIsIndlaWdodCIsImlkIiwiaGFzIiwibmVpZ2hib3JpbmdOb2RlcyIsImFkZCIsImZvckVhY2giLCJuZWlnaGJvcldlaWdodCIsIm5laWdoYm9yIiwibmV3V2VpZ2h0IiwiY3VycmVudElkIiwiZ2V0IiwiY3VycmVudFdlaWdodCIsImdldFBhdGhGcm9tUHJlY2VkZW50c01hcCIsIm5vZGVzIiwibm9kZSIsInJldmVyc2UiLCJmaW5kU2hvcnRlc3RQYXRoIiwiZmluZElkZWFsTm9kZVNlYXJjaCIsInBob3RvcyIsInRhcmdldFJvd0hlaWdodCIsImNvbnRhaW5lcldpZHRoIiwibWluUmF0aW8iLCJyZWR1Y2UiLCJhY2MiLCJwaG90byIsIm1pbiIsIk1BWF9WQUxVRSIsImdldENvbW1vbkhlaWdodCIsInJvdyIsInNwYWNpbmciLCJwYWRkaW5nIiwicm93V2lkdGgiLCJsZW5ndGgiLCJ0b3RhbEFzcGVjdFJhdGlvIiwiY29zdCIsInNsaWNlIiwiY29tbW9uSGVpZ2h0IiwibWFrZUdldFJvd05laWdoYm9ycyIsImxheW91dE9wdGlvbnMiLCJsaW1pdE5vZGVTZWFyY2giLCJyb3dDb25zdHJhaW50cyIsIl9hIiwiX2IiLCJyZXN1bHRzIiwic3RhcnRPZmZzZXQiLCJtaW5QaG90b3MiLCJlbmRPZmZzZXQiLCJtYXhQaG90b3MiLCJJbmZpbml0eSIsImN1cnJlbnRDb3N0IiwiY29tcHV0ZVJvd3NMYXlvdXQiLCJnZXROZWlnaGJvcnMiLCJwYXRoIiwibGF5b3V0IiwibWFwIiwiaW5kZXgiLCJwaG90b0luZGV4IiwicGhvdG9zQ291bnQiLCJjbHN4IiwiY2xhc3NlcyIsImZpbHRlciIsImNscyIsIkJvb2xlYW4iLCJqb2luIiwiY2FsY1dpZHRoIiwiYmFzZSIsInBob3RvTGF5b3V0IiwiY291bnQiLCJjb2x1bW5zIiwiZ2FwcyIsImNzc1Bob3RvV2lkdGgiLCJjYWxjdWxhdGVTaXplc1ZhbHVlIiwibWF0Y2giLCJzcmNTZXRBbmRTaXplcyIsInNyY1NldCIsInNpemVzIiwiaW1hZ2VzIiwiY29uY2F0IiwiZmluZCIsInNyYyIsInNvcnQiLCJmaXJzdCIsInNlY29uZCIsImltYWdlIiwidmlld3BvcnQiLCJjZWlsIiwiUGhvdG9SZW5kZXJlciIsInByb3BzIiwiaW1hZ2VQcm9wcyIsInN0eWxlIiwiY2xhc3NOYW1lIiwicmVzdEltYWdlUHJvcHMiLCJyZW5kZXJQaG90byIsIm9uQ2xpY2siLCJpbWFnZVN0eWxlIiwiZGlzcGxheSIsImJveFNpemluZyIsImFzcGVjdFJhdGlvIiwibWFyZ2luQm90dG9tIiwiY3Vyc29yIiwiaGFuZGxlQ2xpY2siLCJldmVudCIsImFsdCIsInRpdGxlIiwibG9hZGluZyIsImRlY29kaW5nIiwicmVuZGVyRGVmYXVsdFBob3RvIiwib3B0aW9ucyIsInVud3JhcHBlZFN0eWxlIiwicmVzdCIsImNyZWF0ZUVsZW1lbnQiLCJ3cmFwcGVkIiwid3JhcHBlclN0eWxlIiwiRnJhZ21lbnQiLCJkZWZhdWx0UmVuZGVyUm93Q29udGFpbmVyIiwicm93Q29udGFpbmVyUHJvcHMiLCJjaGlsZHJlbiIsIlJvd0NvbnRhaW5lclJlbmRlcmVyIiwicm93SW5kZXgiLCJyb3dzQ291bnQiLCJyZW5kZXJSb3dDb250YWluZXIiLCJyZXN0Um93Q29udGFpbmVyUHJvcHMiLCJmbGV4RGlyZWN0aW9uIiwiZmxleFdyYXAiLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJSb3dzTGF5b3V0IiwiY29tcG9uZW50c1Byb3BzIiwicm93c0xheW91dCIsImtleSIsImNvbXB1dGVTaG9ydGVzdFBhdGgiLCJwYXRoTGVuZ3RoIiwibWF0cml4IiwiY3VycmVudFF1ZXVlIiwia2V5cyIsImNsZWFyIiwiYWNjdW11bGF0ZWRXZWlnaHQiLCJwYXRocyIsIm5leHRQYXRoIiwicmVjb25zdHJ1Y3RTaG9ydGVzdFBhdGgiLCJmaW5kU2hvcnRlc3RQYXRoTGVuZ3RoTiIsIm1ha2VHZXRDb2x1bW5OZWlnaGJvcnMiLCJ0YXJnZXRDb2x1bW5XaWR0aCIsInRhcmdldENvbHVtbkhlaWdodCIsImN1dE9mZkhlaWdodCIsImJ1aWxkQ29sdW1uc01vZGVsIiwiY29sdW1uc0dhcHMiLCJjb2x1bW5zUmF0aW9zIiwiY29sdW1uc01vZGVsIiwidG90YWxSYXRpbyIsInRvdGFsIiwiY29sdW1uUmF0aW8iLCJjb2x1bW4iLCJ0b3RhbEFkanVzdGVkR2FwcyIsImNvbHVtbldpZHRoIiwiY29tcHV0ZUNvbHVtbnNNb2RlbCIsImF2ZXJhZ2VSYXRpbyIsImNvbHVtbnNNb2RlbDIiLCJBcnJheSIsImZyb20iLCJfIiwiY29tcHV0ZUxheW91dCIsImZpbmRJbmRleCIsImNvbHVtbk1vZGVsIiwiY29tcHV0ZUNvbHVtbnNMYXlvdXQiLCJkZWZhdWx0UmVuZGVyQ29sdW1uQ29udGFpbmVyIiwiY29sdW1uQ29udGFpbmVyUHJvcHMiLCJjc3NDb2x1bW5XaWR0aCIsImNvbHVtbkluZGV4IiwiY29sdW1uc0NvdW50IiwicmF0aW8yIiwiQ29sdW1uQ29udGFpbmVyUmVuZGVyZXIiLCJyZW5kZXJDb2x1bW5Db250YWluZXIiLCJyZXN0Q29sdW1uQ29udGFpbmVyUHJvcHMiLCJDb2x1bW5zTGF5b3V0IiwiY29sdW1uc0xheW91dCIsImNvbXB1dGVNYXNvbnJ5TGF5b3V0IiwiY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnMiLCJtb2RlbCIsInNob3J0ZXN0Q29sdW1uIiwiY3VycmVudFNob3J0ZXN0Q29sdW1uIiwiaXRlbSIsIk1hc29ucnlMYXlvdXQiLCJtYXNvbnJ5TGF5b3V0IiwiZGVmYXVsdFJlbmRlckNvbnRhaW5lciIsImNvbnRhaW5lclByb3BzIiwiY29udGFpbmVyUmVmIiwicmVmIiwiQ29udGFpbmVyUmVuZGVyZXIiLCJyZW5kZXJDb250YWluZXIiLCJyZXN0Q29udGFpbmVyUHJvcHMiLCJ1c2VBcnJheSIsImFycmF5IiwidXNlUmVmIiwiY3VycmVudCIsImNvbnRhaW5lcldpZHRoUmVkdWNlciIsInN0YXRlIiwibmV3Q29udGFpbmVyV2lkdGgiLCJuZXdTY3JvbGxiYXJXaWR0aCIsInNjcm9sbGJhcldpZHRoIiwicmVzb2x2ZUNvbnRhaW5lcldpZHRoIiwiYnJlYWtwb2ludHMyIiwiY2xpZW50V2lkdGgiLCJzb3J0ZWQiLCJ4IiwidGhyZXNob2xkIiwiYnJlYWtwb2ludCIsInVzZUNvbnRhaW5lcldpZHRoIiwiZGVmYXVsdENvbnRhaW5lcldpZHRoIiwiZGlzcGF0Y2giLCJ1c2VSZWR1Y2VyIiwib2JzZXJ2ZXJSZWYiLCJ1c2VDYWxsYmFjayIsImRpc2Nvbm5lY3QiLCJ1cGRhdGVXaWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImJyZWFrcG9pbnRzIiwiT2JqZWN0IiwiZnJlZXplIiwidW53cmFwIiwiYXJnIiwidW53cmFwUGFyYW1ldGVyIiwic2VsZWN0UmVzcG9uc2l2ZVZhbHVlIiwidmFsdWVzIiwicmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIiLCJwYXJhbWV0ZXIiLCJtaW5WYWx1ZSIsInJlc29sdmVMYXlvdXRPcHRpb25zIiwidyIsInJlc29sdmVDb21wb25lbnRzUHJvcHMiLCJjb21wb25lbnRzUHJvcHNQcm9wIiwic2luZ2xlUm93TWF4SGVpZ2h0IiwibWF4V2lkdGgiLCJyZW5kZXJMYXlvdXQiLCJjb21tb25MYXlvdXRQcm9wcyIsIlBob3RvQWxidW0iLCJpbmNsdWRlcyIsImlzQXJyYXkiLCJkZWZhdWx0IiwidW5zdGFibGVfY29tcHV0ZUNvbHVtbnNMYXlvdXQiLCJ1bnN0YWJsZV9jb21wdXRlTWFzb25yeUxheW91dCIsInVuc3RhYmxlX2NvbXB1dGVSb3dzTGF5b3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-photo-album/dist/index.mjs\n");

/***/ })

};
;